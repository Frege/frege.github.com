<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<META http-equiv="Content-Type" content="text/html;charset=utf-8">
<TITLE>Data.MicroParsec - frege documentation</TITLE>
<style TYPE="text/css">
body { font-family: helvetica, arial, sans-serif }
pre { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
h3  { font-weight: lighter }
dt.func { background: rgb(95%, 95%, 80%); margin-top: 10px }
dt.clas { background: rgb(80%, 95%, 95%); margin-top: 10px }
dt.inst { background: rgb(95%, 90%, 95%); margin-top: 10px }
dt.data { background: rgb(95%, 95%, 95%); margin-top: 10px }
span.code { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
span.unknown { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: red }
a.fref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(30%, 30%, 0%) }
a.tref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(40%, 0%,  40%) }
</style>
<BODY>
<h1>
Module <SPAN CLASS="code">Data.MicroParsec</SPAN></h1>
<p>
Small parser, inspired by Parsec, but much less versatile. A bit faster and uses less memory than the transformer in Data.NanoParsec.   </p>
<h3>
Imports</h3>
<ul>
<li>
<div>
import <a HREF="../Prelude.html">frege.Prelude</a> as Prelude</div>
</li>
<li>
<div>
import <a HREF="../prelude/PreludeArrays.html">Prelude.PreludeArrays</a> as PreludeArrays</div>
</li>
<li>
<div>
import <a HREF="../prelude/PreludeBase.html">Prelude.PreludeBase</a> as PreludeBase</div>
</li>
<li>
<div>
import <a HREF="../prelude/PreludeIO.html">Prelude.PreludeIO</a> as PreludeIO</div>
</li>
<li>
<div>
import <a HREF="../prelude/PreludeList.html">Prelude.PreludeList</a> as PreludeList</div>
</li>
<li>
<div>
import <a HREF="../prelude/PreludeMonad.html">Prelude.PreludeMonad</a> as PreludeMonad</div>
</li>
<li>
<div>
import <a HREF="../prelude/PreludeText.html">Prelude.PreludeText</a> as PreludeText</div>
</li>
<li>
<div>
import <a HREF="../java/util/Regex.html">Java.util.Regex</a> as Regexp</div>
</li>
</ul>
<h3>
Table of Content</h3>
<ul class="data">
<li>
<div>
<a HREF="#data">Definitions</a></div>
<dl>
<dt>
<SPAN CLASS="code"><b>data </b><a class="tref" href="#Parser"> </a> <a class="tref" href="#Parser">Parser</a> s t r</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#getPos">getPos</a> ∷ <a class="tref" href="#Parser">Parser</a> β α (β α)</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#putPos">putPos</a> ∷ α β → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#modifyPos">modifyPos</a> ∷ (α β→α β) → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#failure">failure</a> ∷ <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#runid">runid</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β γ α</b> → β γ → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | α), β γ)</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#parse">parse</a> ∷ <b><a class="tref" href="#Parser">Parser</a> (β) α γ</b> → (β, α) → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | γ), β)</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#parseTest">parseTest</a> ∷ (<a class="tref" href="../prelude/PreludeText.html#Show">Show</a> r, <a class="tref" href="../prelude/PreludeText.html#Show">Show</a> t, <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> s) ⇒ <b><a class="tref" href="#Parser">Parser</a> s t r</b> → s t → <a class="tref" href="../prelude/PreludeBase.html#IO">IO</a> <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#reporterror">reporterror</a> ∷ (<a class="tref" href="../prelude/PreludeList.html#ListSource">ListSource</a> β, <a class="tref" href="../prelude/PreludeText.html#Show">Show</a> α) ⇒ β α → <b><a class="tref" href="../prelude/PreludeBase.html#String">String</a></b> → <a class="tref" href="../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#label">label</a> ∷ <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <b><a class="tref" href="#Parser">Parser</a> β γ α</b> → <a class="tref" href="#Parser">Parser</a> β γ α</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#_lt_qm_gt">&lt;?&gt;</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ β α</b> → <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> γ β α&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#expect">expect</a> ∷ (<a class="tref" href="../prelude/PreludeText.html#Show">Show</a> α, <a class="tref" href="../prelude/PreludeBase.html#Eq">Eq</a> α, <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β) ⇒ α → <a class="tref" href="#Parser">Parser</a> β α α</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#eos">eos</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#satisfy">satisfy</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> s ⇒ (t → <a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> s t t</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#exceptWhen">exceptWhen</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ (β→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#pany">pany</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ <a class="tref" href="#Parser">Parser</a> β α α</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#symbol">symbol</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <b><a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> β</b> → <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#space">space</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#digit">digit</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#letter">letter</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#uppercase">uppercase</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#spaces">spaces</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#string">string</a> ∷ <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> <a class="tref" href="../prelude/PreludeBase.html#StringJ">StringJ</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#match">match</a> ∷ <a class="tref" href="../java/util/Regex.html#Regex">Regex</a> → <a class="tref" href="#Parser">Parser</a> <a class="tref" href="../prelude/PreludeBase.html#StringJ">StringJ</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../java/util/Regex.html#MatchResult">MatchResult</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#optional">optional</a> ∷ <a class="tref" href="#Parser">Parser</a> s t r → <a class="tref" href="#Parser">Parser</a> s t (<a class="tref" href="../prelude/PreludeBase.html#Maybe">Maybe</a> r)</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#many">many</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β γ</b> → <a class="tref" href="#Parser">Parser</a> α β [γ]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#some">some</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ α β</b> → <a class="tref" href="#Parser">Parser</a> γ α [β]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#many1">many1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ α β</b> → <a class="tref" href="#Parser">Parser</a> γ α [β]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#skip">skip</a> ∷ <a class="tref" href="#Parser">Parser</a> β δ γ → <a class="tref" href="#Parser">Parser</a> β δ <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#manyWhile">manyWhile</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α [α]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#skipWhile">skipWhile</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#skipUntil">skipUntil</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#cond">cond</a> ∷ <a class="tref" href="#Parser">Parser</a> δ γ α → <a class="tref" href="#Parser">Parser</a> δ γ β → <a class="tref" href="#Parser">Parser</a> δ γ β → <a class="tref" href="#Parser">Parser</a> δ γ β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#select">select</a> ∷ <b>[(<a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖇, <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈)]</b> → <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈 → <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#choice">choice</a> ∷ <a class="tref" href="../prelude/PreludeMonad.html#Plus">Plus</a> β ⇒ <b>[β α]</b> → β α</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#count">count</a> ∷ <a class="tref" href="../prelude/PreludeMonad.html#Monad">Monad</a> α ⇒ <b><a class="tref" href="../prelude/PreludeBase.html#Int">Int</a></b> → α β → α [β]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#between">between</a> ∷ <a class="tref" href="../prelude/PreludeMonad.html#Monad">Monad</a> γ ⇒ γ β → γ α → γ δ → γ δ</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#option">option</a> ∷ β → <b><a class="tref" href="#Parser">Parser</a> α γ β</b> → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#sepBy1">sepBy1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β γ α</b> → <a class="tref" href="#Parser">Parser</a> β γ δ → <a class="tref" href="#Parser">Parser</a> β γ [α]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#sepBy">sepBy</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β γ</b> → <a class="tref" href="#Parser">Parser</a> α β δ → <a class="tref" href="#Parser">Parser</a> α β [γ]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#endBy">endBy</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β δ</b> → <a class="tref" href="#Parser">Parser</a> α β γ → <a class="tref" href="#Parser">Parser</a> α β [δ]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#endBy1">endBy1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β δ γ</b> → <a class="tref" href="#Parser">Parser</a> β δ α → <a class="tref" href="#Parser">Parser</a> β δ [γ]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#sepEndBy">sepEndBy</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ δ β</b> → <a class="tref" href="#Parser">Parser</a> γ δ α → <a class="tref" href="#Parser">Parser</a> γ δ [β]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#sepEndBy1">sepEndBy1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β δ</b> → <a class="tref" href="#Parser">Parser</a> α β γ → <a class="tref" href="#Parser">Parser</a> α β [δ]</SPAN></dt>
<dd>
</dd>
</dl>
</li>
<li>
<div>
<a HREF="#instance">Instances</a></div>
<dl>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#MonadAlt_Parser"> </a> <a class="tref" href="../prelude/PreludeMonad.html#MonadAlt">MonadAlt</a> <a class="tref" href="#Parser">Parser</a> s t</SPAN></dt>
<dd>
</dd>
</dl>
</li>
<li>
<div>
<a HREF="#case">Functions and Values by Type</a></div>
</li>
</ul>
<h2>
<a NAME="data">Definitions</a></h2>
<dl class="data">
<dt class="data">
<SPAN CLASS="code"><b>data </b><a name=Parser> </a> <a class="tref" href="#Parser">Parser</a> s t r</SPAN></dt>
<dd class="data">
<p>
Parser Monad</p>
<PRE>
 Parser s t m r</PRE>
<p>
is the type of parsers that reads tokens of type <i>t</i> from a stream <i>s t</i> and returns either an error message string or a result <i>r</i> paired with the yet unprocessed input.</p>
<p>
Works in principle like a combination of <SPAN CLASS="unknown">State</SPAN> and <a class="tref" href="../prelude/PreludeBase.html#Either">Either</a>, where the state is the current input to get parsed, and the bind operations will stop on the first <a class="fref" href="../prelude/PreludeBase.html#Either.Left">Either.Left</a> result, which signals a syntax error.</p>
<p>
<a class="tref" href="#Parser">Parser</a> is also an instance of <a class="tref" href="../prelude/PreludeMonad.html#MonadAlt">MonadAlt</a>. The operations <a class="fref" href="../prelude/PreludeMonad.html#MonadAlt._lt_plus_gt">MonadAlt.&lt;+&gt;</a> and <a class="fref" href="../prelude/PreludeMonad.html#Alt._lt_bar_gt">Alt.&lt;|&gt;</a> can be used to implement choice, i.e. they allow to continue on failure.</p>
<p>
The input for a <a class="tref" href="#Parser">Parser</a> must be something that is an instance of <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a>. Ordinary lists, <a class="tref" href="../prelude/PreludeBase.html#String">String</a>s, <a HREF="./Iterators.html#StringIterator">StringIterator</a> and <a HREF="./Iterators.html#ArrayIterator">ArrayIterator</a> are such types. The parser combinators use only the <a class="fref" href="../prelude/PreludeList.html#ListView.uncons">ListView.uncons</a> and <a class="fref" href="../prelude/PreludeList.html#ListEmpty._null">ListEmpty.null</a> operations.</p>
<h3>
Constructors</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><b>private</b> <a name=Parser.P>P</a> {run ∷ s t → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | r), s t)}</SPAN></dt>
<dd class="func">
</dd>
</dl>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Parser.run>run</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ β α</b> → γ β → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | α), γ β)</SPAN></dt>
<dd class="func">
<p>
access field <SPAN CLASS="code">run</SPAN></p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=getPos>getPos</a> ∷ <a class="tref" href="#Parser">Parser</a> β α (β α)</SPAN></dt>
<dd class="data">
<p>
Remember the current state of the input stream.</p>
<p>
<a class="fref" href="#getPos">getPos</a> always succeeds.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=putPos>putPos</a> ∷ α β → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
Resume parsing with the given input stream.</p>
<p>
<a class="fref" href="#putPos">putPos</a> always succeeds.    </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=modifyPos>modifyPos</a> ∷ (α β→α β) → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=failure>failure</a> ∷ <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd class="data">
<p>
fail with given error message   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=runid>runid</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β γ α</b> → β γ → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | α), β γ)</SPAN></dt>
<dd class="data">
<p>
run a  parser   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=parse>parse</a> ∷ <b><a class="tref" href="#Parser">Parser</a> (β) α γ</b> → (β, α) → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | γ), β)</SPAN></dt>
<dd class="data">
<p>
run a Parser, return just the result/error   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=parseTest>parseTest</a> ∷ (<a class="tref" href="../prelude/PreludeText.html#Show">Show</a> r, <a class="tref" href="../prelude/PreludeText.html#Show">Show</a> t, <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> s) ⇒ <b><a class="tref" href="#Parser">Parser</a> s t r</b> → s t → <a class="tref" href="../prelude/PreludeBase.html#IO">IO</a> <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
run a <a class="tref" href="#Parser">Parser</a> on some input and report   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=reporterror>reporterror</a> ∷ (<a class="tref" href="../prelude/PreludeList.html#ListSource">ListSource</a> β, <a class="tref" href="../prelude/PreludeText.html#Show">Show</a> α) ⇒ β α → <b><a class="tref" href="../prelude/PreludeBase.html#String">String</a></b> → <a class="tref" href="../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=label>label</a> ∷ <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <b><a class="tref" href="#Parser">Parser</a> β γ α</b> → <a class="tref" href="#Parser">Parser</a> β γ α</SPAN></dt>
<dd class="data">
<p>
Causes the error message to be <i>msg</i> when <i>p</i> fails.</p>
<p>
The error will be reported at the position where <i>p</i> was attempted, not necessarily at the position where <i>p</i> failed:</p>
<PRE>
 Parser.run (letter &gt;&gt; digit) "a?"
 unexpected token, found ?
 Parser.run (label "id expected" $ letter &gt;&gt; digit) "a?"
 id expected, found a?</PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=_lt_qm_gt>&lt;?&gt;</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ β α</b> → <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> γ β α<br><b>infix</b>&nbsp;&nbsp;14</SPAN></dt>
<dd class="data">
<PRE>
 p &lt;?&gt; msg</PRE>
<p>
Causes the error message to be <i>msg</i> when <i>p</i> fails.</p>
<p>
The error will be reported at the position where <i>p</i> failed.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=expect>expect</a> ∷ (<a class="tref" href="../prelude/PreludeText.html#Show">Show</a> α, <a class="tref" href="../prelude/PreludeBase.html#Eq">Eq</a> α, <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β) ⇒ α → <a class="tref" href="#Parser">Parser</a> β α α</SPAN></dt>
<dd class="data">
<PRE>
 expect t</PRE>
<p>
This parser succeeds if the input is not empty and the head of the input equals <i>t</i>.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=eos>eos</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
The <a class="fref" href="#eos">eos</a> parser succeeds if the input is empty.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=satisfy>satisfy</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> s ⇒ (t → <a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> s t t</SPAN></dt>
<dd class="data">
<PRE>
 satisfy property</PRE>
<p>
Succeeds if there is a next token <i>t</i> and  <i>property</i> <i>t</i> is true.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=exceptWhen>exceptWhen</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ (β→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<PRE>
 exceptWhen prop</PRE>
<p>
Fails if and only if there is a next token <i>t</i> and <i>prop t</i> is true.</p>
<p>
Succeeds on end of stream or when the token does not satisfy the property.</p>
<p>
In other words, <SPAN CLASS="code">exceptWhen p</SPAN> succeeds if and only if <SPAN CLASS="code">satisfy p</SPAN> fails.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=pany>pany</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ <a class="tref" href="#Parser">Parser</a> β α α</SPAN></dt>
<dd class="data">
<PRE>
 pany</PRE>
<p>
Fails if and only if <a class="fref" href="#eos">eos</a> succeeds, otherwise returns the next token.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=symbol>symbol</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <b><a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> β</b> → <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> β</SPAN></dt>
<dd class="data">
<PRE>
 symbol p</PRE>
<p>
Is the same parser as <i>p</i>, but skips spaces afterwards   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=space>space</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=digit>digit</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=letter>letter</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=uppercase>uppercase</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=spaces>spaces</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=string>string</a> ∷ <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> <a class="tref" href="../prelude/PreludeBase.html#StringJ">StringJ</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=match>match</a> ∷ <a class="tref" href="../java/util/Regex.html#Regex">Regex</a> → <a class="tref" href="#Parser">Parser</a> <a class="tref" href="../prelude/PreludeBase.html#StringJ">StringJ</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../java/util/Regex.html#MatchResult">MatchResult</a></SPAN></dt>
<dd class="data">
<p>
This parser succeeds if the pattern matches the beginning of the string.</p>
<p>
For efficiency reasons, the pattern should start with <SPAN CLASS="code">^</SPAN>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=optional>optional</a> ∷ <a class="tref" href="#Parser">Parser</a> s t r → <a class="tref" href="#Parser">Parser</a> s t (<a class="tref" href="../prelude/PreludeBase.html#Maybe">Maybe</a> r)</SPAN></dt>
<dd class="data">
<p>
The optional parser always succeeds and returns its result wrapped in <a class="tref" href="../prelude/PreludeBase.html#Maybe">Maybe</a>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=many>many</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β γ</b> → <a class="tref" href="#Parser">Parser</a> α β [γ]</SPAN></dt>
<dd class="data">
<PRE>
 many p</PRE>
<p>
Collects as many <i>p</i> as possible and returns the results in a list.</p>
<p>
Succeeds also when <i>p</i> fails the first time, in that case the result is an empty list.</p>
<p>
Must not be applied to a parser that always succeeds!   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=some>some</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ α β</b> → <a class="tref" href="#Parser">Parser</a> γ α [β]</SPAN></dt>
<dd class="data">
<PRE>
 some p</PRE>
<p>
Like <a class="fref" href="#many">many</a>, except there must be at least one <i>p</i></p>
<p>
Must not be applied to a parser that always succeeds!   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=many1>many1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ α β</b> → <a class="tref" href="#Parser">Parser</a> γ α [β]</SPAN></dt>
<dd class="data">
<p>
Alias for <a class="fref" href="#some">some</a></p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=skip>skip</a> ∷ <a class="tref" href="#Parser">Parser</a> β δ γ → <a class="tref" href="#Parser">Parser</a> β δ <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<PRE>
 skip p</PRE>
<p>
equivalent to</p>
<PRE>
 many p &gt;&gt; return ()</PRE>
<p>
but faster, because it does not build up lists.</p>
<p>
Must not be applied to a parser that always succeeds!   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=manyWhile>manyWhile</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α [α]</SPAN></dt>
<dd class="data">
<PRE>
 manyWhile p</PRE>
<p>
Collect tokens as long as they satisfy <i>p</i>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=skipWhile>skipWhile</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<PRE>
 skipWhile p</PRE>
<p>
Skip tokens as long as they <a class="fref" href="#satisfy">satisfy</a> predicate <i>p</i>.</p>
<p>
Beware of negative predicates like</p>
<PRE>
 skipWhile (!= 'a')</PRE>
<p>
This will loop forever if there is no <SPAN CLASS="code">'a'</SPAN> in the input stream. Instead use</p>
<PRE>
 skipUntil (== 'a')</PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=skipUntil>skipUntil</a> ∷ <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<PRE>
 skipUntil p</PRE>
<p>
Skip tokens as long as they do not satisfy p</p>
<p>
When this succeeds, the next token will satisfy p or the stream is exhausted.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=cond>cond</a> ∷ <a class="tref" href="#Parser">Parser</a> δ γ α → <a class="tref" href="#Parser">Parser</a> δ γ β → <a class="tref" href="#Parser">Parser</a> δ γ β → <a class="tref" href="#Parser">Parser</a> δ γ β</SPAN></dt>
<dd class="data">
<PRE>
 cond pcond pthen pelse</PRE>
<p>
if <i>pcond</i> succeeds, then <i>pthen</i> is run, else <i>pelse</i></p>
<p>
To both <i>pthen</i> and <i>pelse</i> it will appear as if <i>pcond</i> didn't consume any tokens.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=select>select</a> ∷ <b>[(<a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖇, <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈)]</b> → <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈 → <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈</SPAN></dt>
<dd class="data">
<PRE>
 select [(if1, t1), (if2, t2), ..., (ifn, tn)] e</PRE>
<p>
unfolds as</p>
<PRE>
 cond if1 t1 (cond if2 t2 (... (cond ifn tn e)))    </PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=choice>choice</a> ∷ <a class="tref" href="../prelude/PreludeMonad.html#Plus">Plus</a> β ⇒ <b>[β α]</b> → β α</SPAN></dt>
<dd class="data">
<PRE>
 choice ps</PRE>
<p>
Tries the parsers in the list from left to right, until success.    </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=count>count</a> ∷ <a class="tref" href="../prelude/PreludeMonad.html#Monad">Monad</a> α ⇒ <b><a class="tref" href="../prelude/PreludeBase.html#Int">Int</a></b> → α β → α [β]</SPAN></dt>
<dd class="data">
<PRE>
 count n p</PRE>
<p>
Applies <i>p</i> <i>n</i> times and returns a list of the results   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=between>between</a> ∷ <a class="tref" href="../prelude/PreludeMonad.html#Monad">Monad</a> γ ⇒ γ β → γ α → γ δ → γ δ</SPAN></dt>
<dd class="data">
<PRE>
 between left right p</PRE>
<p>
Parses <i>left</i>, then <i>p</i> and finally <i>right</i> and returns the result of <i>p</i>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=option>option</a> ∷ β → <b><a class="tref" href="#Parser">Parser</a> α γ β</b> → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd class="data">
<PRE>
 option v p</PRE>
<p>
Applies <i>p</i>, and returns <i>v</i> when it fails.</p>
<p>
Always succeeds.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=sepBy1>sepBy1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β γ α</b> → <a class="tref" href="#Parser">Parser</a> β γ δ → <a class="tref" href="#Parser">Parser</a> β γ [α]</SPAN></dt>
<dd class="data">
<PRE>
 p `sepBy1` q</PRE>
<p>
Parses p and many q followed by p   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=sepBy>sepBy</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β γ</b> → <a class="tref" href="#Parser">Parser</a> α β δ → <a class="tref" href="#Parser">Parser</a> α β [γ]</SPAN></dt>
<dd class="data">
<PRE>
 p `sepBy` q</PRE>
<p>
Like <a class="fref" href="#sepBy1">sepBy1</a>, but allows zero <i>p</i> elements   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=endBy>endBy</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β δ</b> → <a class="tref" href="#Parser">Parser</a> α β γ → <a class="tref" href="#Parser">Parser</a> α β [δ]</SPAN></dt>
<dd class="data">
<PRE>
 p `endBy` q</PRE>
<p>
Parses zero or more occurrences of <i>p</i> separated and ended by <i>q</i>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=endBy1>endBy1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β δ γ</b> → <a class="tref" href="#Parser">Parser</a> β δ α → <a class="tref" href="#Parser">Parser</a> β δ [γ]</SPAN></dt>
<dd class="data">
<PRE>
 p `endBy1` q</PRE>
<p>
Parses one or more occurrences of <i>p</i> separated and ended by <i>q</i>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=sepEndBy>sepEndBy</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ δ β</b> → <a class="tref" href="#Parser">Parser</a> γ δ α → <a class="tref" href="#Parser">Parser</a> γ δ [β]</SPAN></dt>
<dd class="data">
<PRE>
 p `sepEndBy` q</PRE>
<p>
Parses zero or more occurrences of <i>p</i>, separated and optionally ended by <i>q</i>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=sepEndBy1>sepEndBy1</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α β δ</b> → <a class="tref" href="#Parser">Parser</a> α β γ → <a class="tref" href="#Parser">Parser</a> α β [δ]</SPAN></dt>
<dd class="data">
<PRE>
 p `sepEndBy1` q</PRE>
<p>
Parses one or more occurrences of <i>p</i>, separated and optionally ended by <i>q</i>   </p>
</dd>
</dl>
<h2>
<a NAME="instance">Instances</a></h2>
<dl class="inst">
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=MonadAlt_Parser> </a> <a class="tref" href="../prelude/PreludeMonad.html#MonadAlt">MonadAlt</a> <a class="tref" href="#Parser">Parser</a> s t</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._star_gt>*&gt;</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β α δ</b> → <a class="tref" href="#Parser">Parser</a> β α γ → <a class="tref" href="#Parser">Parser</a> β α γ<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._lt_star>&lt;*</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β α δ</b> → <a class="tref" href="#Parser">Parser</a> β α γ → <a class="tref" href="#Parser">Parser</a> β α δ<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._lt_star_gt>&lt;*&gt;</a> ∷ <a class="tref" href="#Parser">Parser</a> α γ (β→δ) → <a class="tref" href="#Parser">Parser</a> α γ β → <a class="tref" href="#Parser">Parser</a> α γ δ<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="../prelude/PreludeMonad.html#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._lt_plus_gt>&lt;+&gt;</a> ∷ <b><a class="tref" href="#Parser">Parser</a> α γ β</b> → <a class="tref" href="#Parser">Parser</a> α γ β → <a class="tref" href="#Parser">Parser</a> α γ β<br><b>infixr</b>&nbsp;&nbsp;13</SPAN></dt>
<dd class="func">
<PRE>
 p &lt;+&gt; q</PRE>
<p>
The result is that of the first parser, if it succeeds, otherwise that of the second one, which is applied to the input left over by <i>p</i></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._lt_bar_gt>&lt;|&gt;</a> ∷ <b><a class="tref" href="#Parser">Parser</a> β α γ</b> → <a class="tref" href="#Parser">Parser</a> β α γ → <a class="tref" href="#Parser">Parser</a> β α γ<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
<PRE>
 p &lt;|&gt; q</PRE>
<p>
The result is that of the first parser, if it succeeds, otherwise that of the second one. Note that <SPAN CLASS="code">q</SPAN> is run on the same input as <SPAN CLASS="code">p</SPAN>, even if <SPAN CLASS="code">p</SPAN> already consumed something.</p>
<PRE>
 expect 'c' &lt;|&gt; expect 'd'</PRE>
<p>
would succeed if the input starts with 'c' or 'd'.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._gt_gt>&gt;&gt;</a> ∷ <b><a class="tref" href="#Parser">Parser</a> δ γ β</b> → <a class="tref" href="#Parser">Parser</a> δ γ α → <a class="tref" href="#Parser">Parser</a> δ γ α<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="../prelude/PreludeMonad.html#Monad._gt_gt">Monad.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._gt_gt_eq>&gt;&gt;=</a> ∷ <b><a class="tref" href="#Parser">Parser</a> δ γ β</b> → (β → <a class="tref" href="#Parser">Parser</a> δ γ α) → <a class="tref" href="#Parser">Parser</a> δ γ α<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
<PRE>
 p &gt;&gt;= (r -&gt; q)
 p &gt;&gt; q</PRE>
<p>
If <SPAN CLASS="code">p</SPAN> succeeds, the overall result is that of <SPAN CLASS="code">q</SPAN> Otherwise, the overall result is failure.</p>
<p>
Could be read as <i>p followed by q</i>.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser.fmap>fmap</a> ∷ (δ → γ) → <b><a class="tref" href="#Parser">Parser</a> β α δ</b> → <a class="tref" href="#Parser">Parser</a> β α γ<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="../prelude/PreludeMonad.html#Monad.fmap">Monad.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser.join>join</a> ∷ <b><a class="tref" href="#Parser">Parser</a> γ β (<a class="tref" href="#Parser">Parser</a> γ β α)</b> → <a class="tref" href="#Parser">Parser</a> γ β α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="../prelude/PreludeMonad.html#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser.pure>pure</a> ∷ γ → <a class="tref" href="#Parser">Parser</a> β α γ</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="../prelude/PreludeMonad.html#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser.pzero>pzero</a> ∷ <a class="tref" href="#Parser">Parser</a> γ β α</SPAN></dt>
<dd class="func">
<p>
generic failure   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt_Parser._return>return</a> ∷ β → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd class="func">
<p>
generic success   </p>
</dd>
</dl>
</dd>
</dl>
<h2>
<a NAME="case">Functions and Values by Type</a></h2>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> <a class="tref" href="../prelude/PreludeBase.html#StringJ">StringJ</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#string">string</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../java/util/Regex.html#Regex">Regex</a> → <a class="tref" href="#Parser">Parser</a> <a class="tref" href="../prelude/PreludeBase.html#StringJ">StringJ</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../java/util/Regex.html#MatchResult">MatchResult</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#match">match</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α → <a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Parser.has$run">Parser.has$run</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#spaces">spaces</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#digit">digit</a>, <a class="fref" href="#letter">letter</a>, <a class="fref" href="#space">space</a>, <a class="fref" href="#uppercase">uppercase</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α β→α β) → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#modifyPos">modifyPos</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α β → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#putPos">putPos</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(<a class="tref" href="../prelude/PreludeList.html#ListSource">ListSource</a> β, <a class="tref" href="../prelude/PreludeText.html#Show">Show</a> α) ⇒ β α → <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#reporterror">reporterror</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> s ⇒ (t → <a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> s t t</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#satisfy">satisfy</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> β → <a class="tref" href="#Parser">Parser</a> α <a class="tref" href="../prelude/PreludeBase.html#Char">Char</a> β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#symbol">symbol</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> α ⇒ (β→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> α β <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#exceptWhen">exceptWhen</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#manyWhile">manyWhile</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ (α→<a class="tref" href="../prelude/PreludeBase.html#Bool">Bool</a>) → <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#skipUntil">skipUntil</a>, <a class="fref" href="#skipWhile">skipWhile</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeMonad.html#Monad">Monad</a> α ⇒ <a class="tref" href="../prelude/PreludeBase.html#Int">Int</a> → α β → α [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#count">count</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeMonad.html#Plus">Plus</a> β ⇒ [β α] → β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#choice">choice</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(<a class="tref" href="../prelude/PreludeText.html#Show">Show</a> α, <a class="tref" href="../prelude/PreludeBase.html#Eq">Eq</a> α, <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β) ⇒ α → <a class="tref" href="#Parser">Parser</a> β α α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#expect">expect</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β α (β α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#getPos">getPos</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ <a class="tref" href="#Parser">Parser</a> β α <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#eos">eos</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> β ⇒ <a class="tref" href="#Parser">Parser</a> β α α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#pany">pany</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(s t → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | r), s t)) → <a class="tref" href="#Parser">Parser</a> s t r</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Parser.P">Parser.P</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> (β) α γ → (β, α) → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | γ), β)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#parse">parse</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> s t r → <a class="tref" href="#Parser">Parser</a> s t (<a class="tref" href="../prelude/PreludeBase.html#Maybe">Maybe</a> r)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#optional">optional</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> α β γ → <a class="tref" href="#Parser">Parser</a> α β [γ]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#many">many</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> α γ β → <a class="tref" href="#Parser">Parser</a> α γ β → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._lt_plus_gt">MonadAlt_Parser.&lt;+&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β α γ → <a class="tref" href="#Parser">Parser</a> β α γ → <a class="tref" href="#Parser">Parser</a> β α γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._lt_bar_gt">MonadAlt_Parser.&lt;|&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β γ α → β γ → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | α), β γ)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#runid">runid</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β δ γ → <a class="tref" href="#Parser">Parser</a> β δ <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#skip">skip</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> γ α β → <a class="tref" href="#Parser">Parser</a> γ α [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#some">some</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> γ β (<a class="tref" href="#Parser">Parser</a> γ β α) → <a class="tref" href="#Parser">Parser</a> γ β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser.join">MonadAlt_Parser.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> γ β α → <a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> γ β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_lt_qm_gt">&lt;?&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> γ β α → γ β → ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | α), γ β)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Parser.run">Parser.run</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> β γ α → <a class="tref" href="#Parser">Parser</a> β γ α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#label">label</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeBase.html#String">String</a> → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#failure">failure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">β → <a class="tref" href="#Parser">Parser</a> α γ β → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#option">option</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">β → <a class="tref" href="#Parser">Parser</a> α γ β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._return">MonadAlt_Parser.return</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">γ → <a class="tref" href="#Parser">Parser</a> β α γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser.pure">MonadAlt_Parser.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(<a class="tref" href="../prelude/PreludeText.html#Show">Show</a> r, <a class="tref" href="../prelude/PreludeText.html#Show">Show</a> t, <a class="tref" href="../prelude/PreludeList.html#ListView">ListView</a> s) ⇒ <a class="tref" href="#Parser">Parser</a> s t r → s t → <a class="tref" href="../prelude/PreludeBase.html#IO">IO</a> <a class="tref" href="../prelude/PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#parseTest">parseTest</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> γ β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser.pzero">MonadAlt_Parser.pzero</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(δ → γ) → <a class="tref" href="#Parser">Parser</a> β α δ → <a class="tref" href="#Parser">Parser</a> β α γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser.fmap">MonadAlt_Parser.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> α β γ → <a class="tref" href="#Parser">Parser</a> α β δ → <a class="tref" href="#Parser">Parser</a> α β [γ]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#sepBy">sepBy</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> α β δ → <a class="tref" href="#Parser">Parser</a> α β γ → <a class="tref" href="#Parser">Parser</a> α β [δ]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#endBy">endBy</a>, <a class="fref" href="#sepEndBy1">sepEndBy1</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> α γ (β→δ) → <a class="tref" href="#Parser">Parser</a> α γ β → <a class="tref" href="#Parser">Parser</a> α γ δ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._lt_star_gt">MonadAlt_Parser.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β α δ → <a class="tref" href="#Parser">Parser</a> β α γ → <a class="tref" href="#Parser">Parser</a> β α γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._star_gt">MonadAlt_Parser.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β α δ → <a class="tref" href="#Parser">Parser</a> β α γ → <a class="tref" href="#Parser">Parser</a> β α δ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._lt_star">MonadAlt_Parser.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β γ α → <a class="tref" href="#Parser">Parser</a> β γ δ → <a class="tref" href="#Parser">Parser</a> β γ [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#sepBy1">sepBy1</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β δ γ → <a class="tref" href="#Parser">Parser</a> β δ α → <a class="tref" href="#Parser">Parser</a> β δ [γ]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#endBy1">endBy1</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> γ δ β → <a class="tref" href="#Parser">Parser</a> γ δ α → <a class="tref" href="#Parser">Parser</a> γ δ [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#sepEndBy">sepEndBy</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> δ γ α → <a class="tref" href="#Parser">Parser</a> δ γ β → <a class="tref" href="#Parser">Parser</a> δ γ β → <a class="tref" href="#Parser">Parser</a> δ γ β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#cond">cond</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> δ γ β → (β → <a class="tref" href="#Parser">Parser</a> δ γ α) → <a class="tref" href="#Parser">Parser</a> δ γ α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._gt_gt_eq">MonadAlt_Parser.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> δ γ β → <a class="tref" href="#Parser">Parser</a> δ γ α → <a class="tref" href="#Parser">Parser</a> δ γ α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt_Parser._gt_gt">MonadAlt_Parser.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[(<a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖇, <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈)] → <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈 → <a class="tref" href="#Parser">Parser</a> 𝖆 𝖉 𝖈</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#select">select</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../prelude/PreludeMonad.html#Monad">Monad</a> γ ⇒ γ β → γ α → γ δ → γ δ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#between">between</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> β α δ → (ζ ε→((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | γ), ζ ε)) → <a class="tref" href="#Parser">Parser</a> ζ ε γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Parser.upd$run">Parser.upd$run</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Parser">Parser</a> δ α ε → (<a class="tref" href="../prelude/PreludeBase.html#Function">-&gt;</a> (δ α) ((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | ε), δ α)→β ζ→((<a class="tref" href="../prelude/PreludeBase.html#String">String</a> | γ), β ζ)) → <a class="tref" href="#Parser">Parser</a> β ζ γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Parser.chg$run">Parser.chg$run</a></p>
</dd>
</dl>
<p>
<a HREF="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></a></p>
</BODY>
</HTML>
