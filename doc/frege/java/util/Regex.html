<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<META http-equiv="Content-Type" content="text/html;charset=utf-8">
<TITLE>Java.util.Regex - frege documentation</TITLE>
<style TYPE="text/css">
body { font-family: helvetica, arial, sans-serif }
pre { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
h3  { font-weight: lighter }
dt.func { background: rgb(95%, 95%, 80%); margin-top: 10px }
dt.clas { background: rgb(80%, 95%, 95%); margin-top: 10px }
dt.inst { background: rgb(95%, 90%, 95%); margin-top: 10px }
dt.data { background: rgb(95%, 95%, 95%); margin-top: 10px }
span.code { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
span.unknown { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: red }
a.fref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(30%, 30%, 0%) }
a.tref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(40%, 0%,  40%) }
</style>
<BODY>
<h1>
Module <SPAN CLASS="code">Java.util.Regex</SPAN></h1>
<p>
Support for working with regular expressions.</p>
<p>
This exposes <SPAN CLASS="code">java.util.regex.Pattern</SPAN> as <a class="tref" href="#Regex">Regex</a> and <SPAN CLASS="code">java.util.regex.MatchResult</SPAN> as <a class="tref" href="#MatchResult">MatchResult</a>.</p>
<p>
This module must have been imported during compilation or certain language features can not be used (see below).</p>
<h2>
Frege language support</h2>
<h3>
Regex literals</h3>
<p>
Regular expression literals have type <a class="tref" href="#Regex">Regex</a> and are written:</p>
<PRE>
 ¬¥\b(foo|bar)\b¬¥       -- string enclosed in grave accents
 '\w+'                 -- string with length &gt; 1 enclosed in apostrophes</PRE>
<p>
The notation with the apostrophes has been introduced because many have a hard time entering a grave accent mark on their terminal. However, it is not possible to write a regular expressions with length 1 this way, because then the literal gets interpreted as <a class="tref" href="../../prelude/PreludeBase.html#Char">Char</a> literal. (One can write something like <SPAN CLASS="code">'(?:X)'</SPAN> for a <a class="tref" href="#Regex">Regex</a> that matches a single <SPAN CLASS="code">'X'</SPAN>).</p>
<p>
The advantage of using literals rather than compiling string constants to patterns at runtime is</p>
<p>
1) they are checked by the Frege compiler, and illegal ones cause compilation to fail</p>
<p>
2) at runtime, literals are available as immutable values of type <SPAN CLASS="code">java.util.regex.Pattern</SPAN>, not as strings, as can be seen so often in human written Java code. Thus the cost of repeated regex compilation is avoided.</p>
<p>
3) The regular expression can be written directly, like in Perl or other languages, without taking String escape rules into account. That is, to match a $ sign, one writes</p>
<PRE>
 ¬¥\$¬¥</PRE>
<p>
and not</p>
<PRE>
 "\\$"</PRE>
<p>
like in Java.</p>
<p>
The <a class="tref" href="#Regex">Regex</a> values created from the literals have the following flags enabled: <a class="fref" href="#Regex.canon_eq">Regex.canon_eq</a>, <a class="fref" href="#Regex.unicode_case">Regex.unicode_case</a> and <a class="fref" href="#Regex.unicode_character_class">Regex.unicode_character_class</a>. That is, they do their best - as far as Java supports it - to get processing of Unicode strings right.</p>
<h3>
<a class="tref" href="#Regex">Regex</a> literals in pattern matching</h3>
<p>
A <a class="tref" href="#Regex">Regex</a> literal is a valid pattern, like any literal:</p>
<PRE>
 case expr1 of
   ¬¥\w+¬¥  ‚Üí  expr2</PRE>
<p>
This is equivalent to:</p>
<PRE>
 case expr1 of
   s | s ~ ¬¥\w+¬¥ ‚Üí  expr2</PRE>
<p>
where <i>s</i> is some fresh variable that doesn't appear in <i>expr2</i>.</p>
<p>
The match succeeds if the <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> value resulting from evaluation of <i>expr1</i> matches the regular expression given. The match diverges when <i>expr1</i> diverges. In all other cases, the match fails.</p>
<p>
Note that in this simple form, the value of <i>expr1</i> is not available in <i>expr2</i>. One can use an "at" pattern for this:</p>
<PRE>
 case expr1 of
    string@'\w+'  ‚Üí  expr2</PRE>
<p>
which gets desugared to</p>
<PRE>
 case expr1 of
   string | string ~ '\w+'  ‚Üí  expr2</PRE>
<p>
leaving <i>string</i> bound to the value of <i>expr1</i>.</p>
<p>
The following syntax not only checks if the regular expression matches but also binds the <a class="tref" href="#MatchResult">MatchResult</a>:</p>
<PRE>
 case expr1 of
   m~'\w+'  ‚Üí  expr2</PRE>
<p>
It is equivalent to</p>
<PRE>
 case expr1 of
   s | Just m ‚Üê s =~ '\w+'  ‚Üí  expr2</PRE>
<p>
where <i>s</i> is again a fresh variable not known in <i>expr2</i>, but when the match succeeds <i>m</i> is bound to the <a class="tref" href="#MatchResult">MatchResult</a> and can be inspected further in <i>expr2</i>.</p>
<p>
And finally, a pattern like</p>
<PRE>
 s@m~'\w+'</PRE>
<p>
works like the previous one but in addition binds <i>s</i> to the string value in question.</p>
<h3>
Imports</h3>
<ul>
<li>
<div>
import <a HREF="../Lang.html">Java.Lang</a> as Lang</div>
</li>
<li>
<div>
import <a HREF="../../prelude/PreludeArrays.html">Prelude.PreludeArrays</a> as PreludeArrays</div>
</li>
<li>
<div>
import <a HREF="../../prelude/PreludeBase.html">Prelude.PreludeBase</a> as PreludeBase</div>
</li>
<li>
<div>
import <a HREF="../../prelude/PreludeIO.html">Prelude.PreludeIO</a> as PreludeIO</div>
</li>
<li>
<div>
import <a HREF="../../prelude/PreludeList.html">Prelude.PreludeList</a> as PreludeList</div>
</li>
<li>
<div>
import <a HREF="../../control/Semigroupoid.html">Control.Semigroupoid</a> as Semigroupoid</div>
</li>
</ul>
<h3>
Table of Content</h3>
<ul class="data">
<li>
<div>
<a HREF="#data">Definitions</a></div>
<dl>
<dt>
<SPAN CLASS="code"><b>class </b> <a class="tref" href="#Replace">Replace</a> s</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>data </b><a class="tref" href="#MatchResult"> </a> <a class="tref" href="#MatchResult">MatchResult</a> = <b>pure </b><b>native </b>java.util.regex.MatchResult</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>data </b><a class="tref" href="#PatternSyntaxException"> </a> <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> = <b>native </b>java.util.regex.PatternSyntaxException</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>data </b><a class="tref" href="#Regex"> </a> <a class="tref" href="#Regex">Regex</a> = <b>pure </b><b>native </b>java.util.regex.Pattern</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#regcomp">regcomp</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)&nbsp;<a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#regforce">regforce</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a>&nbsp;<a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="#Regex">Regex</a>&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#regforceùñÜ">regforceùñÜ</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="#Regex">Regex</a>&nbsp;&nbsp;&nbsp;<b>overloads </b><a class="fref" href="#regforce">regforce</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#regforceùñá">regforceùñá</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí <a class="tref" href="#Regex">Regex</a>&nbsp;&nbsp;&nbsp;<b>overloads </b><a class="fref" href="#regforce">regforce</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#substituteFirst">substituteFirst</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#substituteAll">substituteAll</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#$eq$tilde">=~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a>&nbsp;&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#findAt">findAt</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a>&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#$eq$tilde$tilde">=~~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#$tilde">~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Bool">Bool</a>&nbsp;&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#$excl$tilde">!~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Bool">Bool</a>&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#$tilde$tilde">~~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#$tilde$tilde$tilde">~~~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#$tilde$tilde$star">~~*</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]&nbsp;</SPAN></dt>
<dd>
</dd>
</dl>
</li>
<li>
<div>
<a HREF="#instance">Instances</a></div>
<dl>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Exceptional_PatternSyntaxException"> </a><a class="tref" href="../../prelude/PreludeIO.html#Exceptional">Exceptional</a> <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Replace_String"> </a><a class="tref" href="#Replace">Replace</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd>
</dd>
</dl>
</li>
<li>
<div>
<a HREF="#case">Functions and Values by Type</a></div>
</li>
</ul>
<h2>
<a NAME="data">Definitions</a></h2>
<dl class="data">
<dt class="data">
<SPAN CLASS="code"><b>data </b><a name=Regex> </a> <a class="tref" href="#Regex">Regex</a> = <b>pure </b><b>native </b>java.util.regex.Pattern</SPAN></dt>
<dd class="data">
<p>
<a class="tref" href="#Regex">Regex</a> values are based on Java's <SPAN CLASS="code">java.util.regex.Pattern</SPAN> objects, which are compiled representations of regular expressions.</p>
<p>
We call them <a class="tref" href="#Regex">Regex</a> and not <SPAN CLASS="code">Pattern</SPAN> in Frege, because the word "pattern" and the phrase "pattern matching" have a quite different meaning in deconstruction of algebraic data types.</p>
<p>
There are 2 ways to obtain a compiled regular expression:</p>
<ol>
<LI>
 Use a <a class="tref" href="#Regex">Regex</a> literal, see the language reference section 2.7.3. All regular expression literals are values of type <a class="tref" href="#Regex">Regex</a>. It is not possible to run a program which contains a syntactically invalid <a class="tref" href="#Regex">Regex</a> literal - the compiler will flag it already at compile time. Hence, with <a class="tref" href="#Regex">Regex</a> literals one is immune against <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a>s.</LI>
<LI>
 Compile a String with <a class="fref" href="#Regex.compile">Regex.compile</a> or <a class="fref" href="#regforce">regforce</a> at run-time. Illegal regular expression will cause <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> to be thrown, which, when not handled appropriately, may crash the program.</LI>
</ol>
<p>
<a class="tref" href="#Regex">Regex</a> values are immutable.</p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Regex.canon_eq>canon_eq</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.CANON_EQ</SPAN></dt>
<dd class="func">
<p>
Enables canonical equivalence.</p>
<p>
When this flag is specified then two characters will be considered to match if, and only if, their full canonical decompositions match. The expression <SPAN CLASS="code">¬¥a\u030A¬¥</SPAN>, for example, will match the string <SPAN CLASS="code">"\u00E5"</SPAN> when this flag is specified.</p>
<p>
There is no embedded flag character for enabling canonical equivalence.</p>
<p>
Specifying this flag may impose a performance penalty.</p>
<p>
Frege <a class="tref" href="#Regex">Regex</a> literals will always be parsed with this flag.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.case_insensitive>case_insensitive</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.CASE_INSENSITIVE</SPAN></dt>
<dd class="func">
<p>
Enables case-insensitive matching.</p>
<p>
By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched. Unicode-aware case-insensitive matching can be enabled by specifying the <a class="fref" href="#Regex.unicode_case">Regex.unicode_case</a> flag in conjunction with this flag.</p>
<p>
Case-insensitive matching can also be enabled via the embedded flag expression (?i).</p>
<p>
Specifying this flag may impose a slight performance penalty.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.comments>comments</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.COMMENTS</SPAN></dt>
<dd class="func">
<p>
Permits whitespace and comments in pattern.</p>
<p>
In this mode, whitespace is ignored, and embedded comments starting with <SPAN CLASS="code">#</SPAN> are ignored until the end of a line.</p>
<p>
Comments mode can also be enabled via the embedded flag expression <SPAN CLASS="code">(?x)</SPAN>.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.compile>compile</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)<br><b>pure </b><b>native </b>java.util.regex.Pattern.compile</SPAN></dt>
<dd class="func">
<p>
compile a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a></p>
<p>
Returns <a class="fref" href="../../prelude/PreludeBase.html#either">either</a> a  <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> in <a class="fref" href="../../prelude/PreludeBase.html#Either.Left">Either.Left</a> or a <a class="tref" href="#Regex">Regex</a> in <a class="fref" href="../../prelude/PreludeBase.html#Either.Right">Either.Right</a>.</p>
<p>
The overloaded form has an additional <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> argument which is a set of flags. Such a set can be constructed by adding up the individual flag values, for example:</p>
<PRE>
  Regex.compile "foo|bar" (Regex.canon_eq + Regex.case_insensitive)</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.compileùñÜ>compileùñÜ</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)<br><b>pure </b><b>native </b>java.util.regex.Pattern.compile&nbsp;&nbsp;<b>overloads </b><a class="fref" href="#Regex.compile">compile</a></SPAN></dt>
<dd class="func">
<p>
compile a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a></p>
<p>
Returns <a class="fref" href="../../prelude/PreludeBase.html#either">either</a> a  <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> in <a class="fref" href="../../prelude/PreludeBase.html#Either.Left">Either.Left</a> or a <a class="tref" href="#Regex">Regex</a> in <a class="fref" href="../../prelude/PreludeBase.html#Either.Right">Either.Right</a>.</p>
<p>
The overloaded form has an additional <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> argument which is a set of flags. Such a set can be constructed by adding up the individual flag values, for example:</p>
<PRE>
  Regex.compile "foo|bar" (Regex.canon_eq + Regex.case_insensitive)</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.compileùñá>compileùñá</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)<br><b>pure </b><b>native </b>java.util.regex.Pattern.compile&nbsp;&nbsp;<b>overloads </b><a class="fref" href="#Regex.compile">compile</a></SPAN></dt>
<dd class="func">
<p>
compile a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a></p>
<p>
Returns <a class="fref" href="../../prelude/PreludeBase.html#either">either</a> a  <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> in <a class="fref" href="../../prelude/PreludeBase.html#Either.Left">Either.Left</a> or a <a class="tref" href="#Regex">Regex</a> in <a class="fref" href="../../prelude/PreludeBase.html#Either.Right">Either.Right</a>.</p>
<p>
The overloaded form has an additional <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> argument which is a set of flags. Such a set can be constructed by adding up the individual flag values, for example:</p>
<PRE>
  Regex.compile "foo|bar" (Regex.canon_eq + Regex.case_insensitive)</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.dotall>dotall</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.DOTALL</SPAN></dt>
<dd class="func">
<p>
Enables dotall mode.</p>
<p>
In dotall mode, the expression <SPAN CLASS="code">.</SPAN> matches any character, including a line terminator. By default this expression does not match line terminators.</p>
<p>
Dotall mode can also be enabled via the embedded flag expression <SPAN CLASS="code">(?s)</SPAN>. (The <SPAN CLASS="code">s</SPAN> is a mnemonic for "single-line" mode, which is what this is called in Perl.)</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.flags>flags</a> ‚à∑ <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>flags</SPAN></dt>
<dd class="func">
<p>
return the flags this pattern was compiled with   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.literal>literal</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.LITERAL</SPAN></dt>
<dd class="func">
<p>
Enables literal parsing of the pattern.</p>
<p>
When this flag is specified then the input string that specifies the pattern is treated as a sequence of literal characters. Metacharacters or escape sequences in the input sequence will be given no special meaning.</p>
<p>
The flags <a class="fref" href="#Regex.case_insensitive">Regex.case_insensitive</a> and <a class="fref" href="#Regex.unicode_case">Regex.unicode_case</a> retain their impact on matching when used in conjunction with this flag. The other flags become superfluous.</p>
<p>
There is no embedded flag character for enabling literal parsing.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.multiline>multiline</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.MULTILINE</SPAN></dt>
<dd class="func">
<p>
Enables multiline mode.</p>
<p>
In multiline mode the expressions <SPAN CLASS="code">^</SPAN> and <SPAN CLASS="code">$</SPAN> match just after or just before, respectively, a line terminator or the end of the input sequence. By default these expressions only match at the beginning and the end of the entire input sequence.</p>
<p>
Multiline mode can also be enabled via the embedded flag expression <SPAN CLASS="code">(?m)</SPAN>.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.pattern>pattern</a> ‚à∑ <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>pattern</SPAN></dt>
<dd class="func">
<p>
return the source of this <a class="tref" href="#Regex">Regex</a>   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.split>split</a> ‚à∑ <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeArrays.html#JArray">JArray</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>split</SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">java.util.regex.Pattern.split</SPAN> method</p>
<p>
As this returns a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> array, one usually uses <a class="fref" href="#Regex.splitted">Regex.splitted</a>    </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.splitted>splitted</a> ‚à∑ <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]</SPAN></dt>
<dd class="func">
<p>
Split a string around matches of a regular expression and return the result as list of strings.</p>
<p>
Empty strings on the start of the string are preserved, but not those on the end of the string, e.g.:</p>
<PRE>
  ¬¥,¬¥.splitted ",,a,b,c,," == ["", "", "a", "b", "c"]</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.toString>toString</a> ‚à∑ <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>toString</SPAN></dt>
<dd class="func">
<p>
Returns the string representation of this pattern.</p>
<p>
This is the regular expression from which this pattern was <a class="fref" href="#Regex.compile">Regex.compile</a>d.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.unicode_case>unicode_case</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.UNICODE_CASE</SPAN></dt>
<dd class="func">
<p>
Enables Unicode-aware case folding.</p>
<p>
When this flag is specified then case-insensitive matching, when enabled by the <a class="fref" href="#Regex.case_insensitive">Regex.case_insensitive</a> flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</p>
<p>
Unicode-aware case folding can also be enabled via the embedded flag expression <SPAN CLASS="code">(?u)</SPAN>.</p>
<p>
Specifying this flag may impose a performance penalty.</p>
<p>
Because Frege <a class="tref" href="#Regex">Regex</a> literals will always be parsed with the <a class="fref" href="#Regex.unicode_character_class">Regex.unicode_character_class</a> flag, this flag is also implicitly enabled by default.</p>
<p>
It can be disabled with the embedded flag expression <SPAN CLASS="code">(?-u)</SPAN>.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.unicode_character_class>unicode_character_class</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.UNICODE_CHARACTER_CLASS</SPAN></dt>
<dd class="func">
<p>
Enables the Unicode version of Predefined character classes and POSIX character classes.</p>
<p>
When this flag is specified then the (US-ASCII only) Predefined character classes and POSIX character classes are in conformance with <a HREF="http://www.unicode.org/reports/tr18/">Unicode Technical Standard #18: Unicode Regular Expression</a> Annex C: Compatibility Properties.</p>
<p>
The <a class="fref" href="#Regex.unicode_character_class">Regex.unicode_character_class</a> mode can also be enabled via the embedded flag expression <SPAN CLASS="code">(?U)</SPAN>.</p>
<p>
The flag implies <a class="fref" href="#Regex.unicode_case">Regex.unicode_case</a>, that is, it enables Unicode-aware case folding.</p>
<p>
Specifying this flag may impose a performance penalty.</p>
<p>
Frege <a class="tref" href="#Regex">Regex</a> literals will always be parsed with this flag. It can be disabled with the embedded flag expression <SPAN CLASS="code">(?-U)</SPAN>.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Regex.unix_lines>unix_lines</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.UNIX_LINES</SPAN></dt>
<dd class="func">
<p>
Enables UNIX lines mode.</p>
<p>
In this mode, only the <SPAN CLASS="code">\n</SPAN> line terminator is recognized in the behavior of <SPAN CLASS="code">.</SPAN>, <SPAN CLASS="code">^</SPAN>, and <SPAN CLASS="code">$</SPAN>.</p>
<p>
Unix lines mode can also be enabled via the embedded flag expression <SPAN CLASS="code">(?d)</SPAN>.   </p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>data </b><a name=PatternSyntaxException> </a> <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> = <b>native </b>java.util.regex.PatternSyntaxException</SPAN></dt>
<dd class="data">
<p>
Will be thrown when one compiles a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a> using <a class="fref" href="#Regex.compile">Regex.compile</a> or <a class="fref" href="#regforce">regforce</a>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=regcomp>regcomp</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)<br><b>pure </b><b>native </b>java.util.regex.Pattern.compile</SPAN></dt>
<dd class="data">
<p>
Alias for <a class="fref" href="#Regex.compile">Regex.compile</a></p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=regforce>regforce</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="#Regex">Regex</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.compile</SPAN></dt>
<dd class="data">
<p>
compile a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a></p>
<p>
This will throw <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> when the regular expression is illegal.</p>
<p>
Use this only if you're sure that pattern compilation will not throw an exception, or if you don't care.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=regforceùñÜ>regforceùñÜ</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="#Regex">Regex</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.compile&nbsp;&nbsp;<b>overloads </b><a class="fref" href="#regforce">regforce</a></SPAN></dt>
<dd class="data">
<p>
compile a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a></p>
<p>
This will throw <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> when the regular expression is illegal.</p>
<p>
Use this only if you're sure that pattern compilation will not throw an exception, or if you don't care.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=regforceùñá>regforceùñá</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí <a class="tref" href="#Regex">Regex</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.compile&nbsp;&nbsp;<b>overloads </b><a class="fref" href="#regforce">regforce</a></SPAN></dt>
<dd class="data">
<p>
compile a <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a></p>
<p>
This will throw <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> when the regular expression is illegal.</p>
<p>
Use this only if you're sure that pattern compilation will not throw an exception, or if you don't care.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b> <a name=Replace>Replace</a> s</SPAN></dt>
<dd class="data">
<p>
this is only used to inject the replace functions into <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>   </p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Replace_String">StringJ</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Replace.replaceAll>replaceAll</a> ‚à∑ <a class="tref" href="#Replace">Replace</a> s ‚áí s ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí s ‚Üí s</SPAN></dt>
<dd class="func">
<p>
Like <a class="fref" href="#Replace.replaceFirst">Replace.replaceFirst</a>, but replaces <b>all</b> substrings that match the pattern.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Replace.replaceFirst>replaceFirst</a> ‚à∑ <a class="tref" href="#Replace">Replace</a> s ‚áí s ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí s ‚Üí s</SPAN></dt>
<dd class="func">
<p>
Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.</p>
<p>
This method scans the input sequence from the start looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences.</p>
<p>
Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.</p>
<p>
For example</p>
<PRE>
 replaceFirst "zzzdogzzzdogzzz" ¬¥dog¬¥ "cat" == "zzzcatzzzdogzzz"</PRE>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=substituteFirst>substituteFirst</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>frege.runtime.Regex9.replaceFirst</SPAN></dt>
<dd class="data">
<p>
Alias for <a class="fref" href="#Replace_String.replaceFirst">Replace_String.replaceFirst</a></p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=substituteAll>substituteAll</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>frege.runtime.Regex9.replaceAll</SPAN></dt>
<dd class="data">
<p>
Alias for <a class="fref" href="#Replace_String.replaceAll">Replace_String.replaceAll</a></p>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>data </b><a name=MatchResult> </a> <a class="tref" href="#MatchResult">MatchResult</a> = <b>pure </b><b>native </b>java.util.regex.MatchResult</SPAN></dt>
<dd class="data">
<p>
This interface contains query methods used to determine the results of a match against a regular expression.</p>
<p>
More: <a HREF="https://docs.oracle.com/javase/7/docs/api/java/util/regex/MatchResult.html">JavaDoc</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MatchResult.end>end</a> ‚à∑ <b><a class="tref" href="#MatchResult">MatchResult</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>end</SPAN></dt>
<dd class="func">
<p>
Returns the offset after the last character of the subsequence captured by the given group during the previous match operation where group 0 denotes the entire pattern.</p>
<p>
If the specified capturing group failed to match, the return value will be -1.</p>
<p>
The following property holds:</p>
<PRE>
 (m.group n == Nothing) ==&gt; (m.end n &lt; 0)</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MatchResult.group>group</a> ‚à∑ <b><a class="tref" href="#MatchResult">MatchResult</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<PRE>
 group m n</PRE>
<p>
retrieves the input subsequence captured by the given group index during the previous match operation.</p>
<p>
Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression <SPAN CLASS="code">(m.group 0)</SPAN> retrieves that portion of the input string that was matched by the pattern.</p>
<p>
If the match was successful but the group specified failed to match any part of the input sequence, then <a class="fref" href="../../prelude/PreludeBase.html#Maybe.Nothing">Maybe.Nothing</a> is returned.</p>
<p>
Note that some groups, for example <SPAN CLASS="code">(a?)</SPAN>, match the empty string. This function will return <SPAN CLASS="code">Just ""</SPAN> when such a group successfully matches the empty string in the input.</p>
<p>
The result will also be <a class="fref" href="../../prelude/PreludeBase.html#Maybe.Nothing">Maybe.Nothing</a> when the specified group does not exist, that is, when the <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> argument is outside the range <SPAN CLASS="code">[0..</SPAN><a class="fref" href="#MatchResult.groupCount">MatchResult.groupCount</a> <SPAN CLASS="code">m]</SPAN></p>
<p>
The following property holds for a <a class="tref" href="#MatchResult">MatchResult</a> <i>m</i> with input sequence <i>s</i> and valid group index <i>g</i>:</p>
<PRE>
 isJust (m.group g) ==&gt; (m.group g) == Just (s.substr (m.start g) (m.end g))</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MatchResult.groupCount>groupCount</a> ‚à∑ <b><a class="tref" href="#MatchResult">MatchResult</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>groupCount</SPAN></dt>
<dd class="func">
<p>
Returns the number of capturing groups in this matcher's pattern.</p>
<p>
Group zero denotes the entire pattern by convention. It is not included in this count.</p>
<p>
Any non-negative integer smaller than or equal to the value returned by this method is guaranteed to be a valid group index for this matcher.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MatchResult.groupPrim>groupPrim</a> ‚à∑ <b><a class="tref" href="#MatchResult">MatchResult</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí (<a class="tref" href="../Lang.html#IndexOutOfBoundsException">IndexOutOfBoundsException</a> | <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>)<br><b>pure </b><b>native </b>group</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MatchResult.groups>groups</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a></b> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]</SPAN></dt>
<dd class="func">
<p>
The list of subsequences captured during the previous match operation, or the empty list if there was no match.</p>
<p>
To be used like:</p>
<PRE>
 groups $ s =~ regex</PRE>
<p>
See also <a class="fref" href="#$eq$tilde$tilde">=~~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MatchResult.match>match</a> ‚à∑ <b><a class="tref" href="#MatchResult">MatchResult</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>group</SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">MatchResult.match m</SPAN> returns the input subsequence matched by the previous match. The result is <a class="fref" href="../../prelude/PreludeBase.html#undefined">undefined</a> if the last match was not successful.</p>
<p>
For a <a class="tref" href="#MatchResult">MatchResult</a> <SPAN CLASS="code">m</SPAN> with input sequence <SPAN CLASS="code">s</SPAN>, the following holds:</p>
<PRE>
 isJust (m.group 0) ==&gt; unJust (m.group 0) == m.match</PRE>
<p>
Note that some patterns, for example <SPAN CLASS="code">a?</SPAN>, match the empty string. This method will return the empty string when the pattern successfully matches the empty string in the input.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MatchResult.start>start</a> ‚à∑ <b><a class="tref" href="#MatchResult">MatchResult</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>start</SPAN></dt>
<dd class="func">
<p>
Returns the start index of the subsequence captured by the given group during the previous match operation where group 0 denotes the entire pattern.</p>
<p>
If the specified capturing group failed to match, the return value will be -1.</p>
<p>
The following property holds:</p>
<PRE>
 (m.group n == Nothing) ==&gt; (m.start n &lt; 0)</PRE>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=$eq$tilde>=~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a><br><b>pure </b><b>native </b>frege.runtime.Regex9.findResult<br><b>infix</b>&nbsp;&nbsp;15</SPAN></dt>
<dd class="data">
<PRE>
 string =~ regex</PRE>
<p>
tries to match <i>string</i> against <i>regex</i> and returns <SPAN CLASS="code">Just matcher</SPAN> if it succeeds, <SPAN CLASS="code">Nothing</SPAN> otherwise.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=findAt>findAt</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a><br><b>pure </b><b>native </b>frege.runtime.Regex9.findResult</SPAN></dt>
<dd class="data">
<PRE>
 findAt string regex offset</PRE>
<p>
Like <a class="fref" href="#$eq$tilde">=~</a>, but matches only the substring of <i>string</i> that starts at <i>offset</i> against <i>regex</i>.</p>
<p>
If <i>offset</i> is  negative or not smaller than the length of <i>string</i>, the result is <i>Nothing</i></p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=$eq$tilde$tilde>=~~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]<br><b>infix</b>&nbsp;&nbsp;15</SPAN></dt>
<dd class="data">
<PRE>
 string =~~ regex</PRE>
<p>
tries to match <i>string</i> against <i>regex</i> and returns a list of all captured substrings, see <a class="fref" href="#MatchResult.groups">MatchResult.groups</a>.</p>
<p>
Example:</p>
<PRE>
 case "today is 2014-02-18" =~~ ¬¥(\d\d\d\d)-(0[1-9]|1[012])-(\d\d)¬¥ of
    [Just date, Just year, Just month, Just day] -&gt; ...
    baddate -&gt; ....</PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=$tilde>~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Bool">Bool</a><br><b>pure </b><b>native </b>frege.runtime.Regex9.find<br><b>infix</b>&nbsp;&nbsp;15</SPAN></dt>
<dd class="data">
<PRE>
string ~ regex</PRE>
<p>
<SPAN CLASS="code">true</SPAN> if <i>string</i> matches <i>regex</i>, <SPAN CLASS="code">false</SPAN> otherwise</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=$excl$tilde>!~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Bool">Bool</a><br><b>infix</b>&nbsp;&nbsp;15</SPAN></dt>
<dd class="data">
<PRE>
 s !~ p == !(s ~ p)</PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=$tilde$tilde>~~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>infix</b>&nbsp;&nbsp;15</SPAN></dt>
<dd class="data">
<PRE>
 ("string" ~~ ¬¥r..¬¥) == Just "rin"</PRE>
<p>
Tries a match and returns <SPAN CLASS="code">Just x</SPAN> where <i>x</i> is the matched substring or <SPAN CLASS="code">Nothing</SPAN> if there was no match.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=$tilde$tilde$tilde>~~~</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>infix</b>&nbsp;&nbsp;15</SPAN></dt>
<dd class="data">
<PRE>
 string ~~~ regex</PRE>
<p>
Matches <i>string</i> with <i>regex</i> and returns a function that can be used to extract the matched part of the string and the captured substrings.</p>
<PRE>
   let f = "frege" ~~~ ¬¥(..).(..)¬¥
   in [ f i | i &lt;- 0..3 ]</PRE>
<p>
yields</p>
<PRE>
[Just "frege", Just "fr", Just "ge", Nothing]</PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=$tilde$tilde$star>~~*</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]<br><b>infix</b>&nbsp;&nbsp;15</SPAN></dt>
<dd class="data">
<PRE>
 "cats and dogs are not concatenated." ~~* ¬¥cat|dog¬¥</PRE>
<p>
Matches the string with the regex and returns a list of all matches. The example gives:</p>
<PRE>
 ["cat", "dog", "cat"]</PRE>
</dd>
</dl>
<h2>
<a NAME="instance">Instances</a></h2>
<dl class="inst">
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Exceptional_PatternSyntaxException> </a><a class="tref" href="../../prelude/PreludeIO.html#Exceptional">Exceptional</a> <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Exceptional_PatternSyntaxException.javaClass>javaClass</a> ‚à∑ <a class="tref" href="../../prelude/PreludeBase.html#Class">Class</a> <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a><br><b>pure </b><b>native </b>java.util.regex.PatternSyntaxException.class</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Replace_String> </a><a class="tref" href="#Replace">Replace</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Replace_String.replaceAll>replaceAll</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>frege.runtime.Regex9.replaceAll</SPAN></dt>
<dd class="func">
<p>
Like <SPAN CLASS="unknown">String.replaceFirst</SPAN>, but replaces <b>all</b> substrings that match the pattern.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Replace_String.replaceFirst>replaceFirst</a> ‚à∑ <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <b><a class="tref" href="#Regex">Regex</a></b> ‚Üí <b><a class="tref" href="../../prelude/PreludeBase.html#String">String</a></b> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>frege.runtime.Regex9.replaceFirst</SPAN></dt>
<dd class="func">
<p>
Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.</p>
<p>
This method scans the input sequence from the start looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences.</p>
<p>
Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.</p>
<p>
For example</p>
<PRE>
 "zzzdogzzzdogzzz".replaceFirst  ¬¥dog¬¥ "cat" == "zzzcatzzzdogzzz"</PRE>
</dd>
</dl>
</dd>
</dl>
<h2>
<a NAME="case">Functions and Values by Type</a></h2>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MatchResult.groups">MatchResult.groups</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Replace_String.replaceFirst">Replace_String.replaceFirst</a>, <a class="fref" href="#Replace_String.replaceAll">Replace_String.replaceAll</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#$tilde$tilde$tilde">~~~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#findAt">findAt</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#$tilde$tilde">~~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#MatchResult">MatchResult</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#$eq$tilde">=~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#$eq$tilde$tilde">=~~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#$tilde$tilde$star">~~*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Bool">Bool</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#$excl$tilde">!~</a>, <a class="fref" href="#$tilde">~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.compileùñá">Regex.compileùñá</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="#Regex">Regex</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#regforceùñá">regforceùñá</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.compileùñÜ">Regex.compileùñÜ</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="#Regex">Regex</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#regforceùñÜ">regforceùñÜ</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MatchResult">MatchResult</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí (<a class="tref" href="../Lang.html#IndexOutOfBoundsException">IndexOutOfBoundsException</a> | <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a>)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MatchResult.groupPrim">MatchResult.groupPrim</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MatchResult">MatchResult</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MatchResult.group">MatchResult.group</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MatchResult">MatchResult</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MatchResult.start">MatchResult.start</a>, <a class="fref" href="#MatchResult.end">MatchResult.end</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MatchResult">MatchResult</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MatchResult.match">MatchResult.match</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MatchResult">MatchResult</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MatchResult.groupCount">MatchResult.groupCount</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí <a class="tref" href="../../prelude/PreludeArrays.html#JArray">JArray</a> <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.split">Regex.split</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a> ‚Üí [<a class="tref" href="../../prelude/PreludeBase.html#String">String</a>]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.splitted">Regex.splitted</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.toString">Regex.toString</a>, <a class="fref" href="#Regex.pattern">Regex.pattern</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Regex">Regex</a> ‚Üí <a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.flags">Regex.flags</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#Class">Class</a> <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Exceptional_PatternSyntaxException.javaClass">Exceptional_PatternSyntaxException.javaClass</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="../../prelude/PreludeBase.html#Int">Int</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.unix_lines">Regex.unix_lines</a>, <a class="fref" href="#Regex.unicode_case">Regex.unicode_case</a>, <a class="fref" href="#Regex.unicode_character_class">Regex.unicode_character_class</a>, <a class="fref" href="#Regex.multiline">Regex.multiline</a>, <a class="fref" href="#Regex.dotall">Regex.dotall</a>, <a class="fref" href="#Regex.literal">Regex.literal</a>, <a class="fref" href="#Regex.comments">Regex.comments</a>, <a class="fref" href="#Regex.canon_eq">Regex.canon_eq</a>, <a class="fref" href="#Regex.case_insensitive">Regex.case_insensitive</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Replace">Replace</a> s ‚áí s ‚Üí <a class="tref" href="#Regex">Regex</a> ‚Üí s ‚Üí s</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Replace.replaceFirst">Replace.replaceFirst</a>, <a class="fref" href="#Replace.replaceAll">Replace.replaceAll</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">œâ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#regforce">regforce</a>, <a class="fref" href="#Regex.compile">Regex.compile</a></p>
</dd>
</dl>
<p>
<a HREF="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></a></p>
</BODY>
</HTML>
