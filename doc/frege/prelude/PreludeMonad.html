<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<META http-equiv="Content-Type" content="text/html;charset=utf-8">
<TITLE>Prelude.PreludeMonad - frege documentation</TITLE>
<style TYPE="text/css">
body { font-family: helvetica, arial, sans-serif }
pre { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
h3  { font-weight: lighter }
dt.func { background: rgb(95%, 95%, 80%); margin-top: 10px }
dt.clas { background: rgb(80%, 95%, 95%); margin-top: 10px }
dt.inst { background: rgb(95%, 90%, 95%); margin-top: 10px }
dt.data { background: rgb(95%, 95%, 95%); margin-top: 10px }
span.code { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
span.unknown { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: red }
a.fref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(30%, 30%, 0%) }
a.tref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(40%, 0%,  40%) }
</style>
<BODY>
<h1>
Module <SPAN CLASS="code">Prelude.PreludeMonad</SPAN></h1>
<p>
This package provides the <a class="tref" href="#Monad">Monad</a> class and related classes and functions.</p>
<p>
The class hierarchy is derived from the (Haskell) proposal <b>The Other Prelude</b> but the traditional method names have been kept.</p>
<p>
The functions in this library use the following naming conventions:</p>
<ul>
<LI>
 A postfix "M"" always stands for a function in the Kleisli category: The monad type constructor <i>m</i> is added to function results (modulo currying) and nowhere else. So, for example,</LI>
</ul>
<PRE>
 filter ::               (a -&gt; Bool)   -&gt; [a] -&gt; [a]
 filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]</PRE>
<ul>
<LI>
 A postfix "<i>" changes the result type from (</i>m a<i>) to (</i>m ()_). Thus, for example: </LI>
</ul>
<PRE>
 sequence  :: Monad m =&gt; [m a] -&gt; m [a]
 sequence_ :: Monad m =&gt; [m a] -&gt; m ()</PRE>
<ul>
<LI>
 A prefix "m" generalizes an existing function to a monadic form. Thus, for example: </LI>
</ul>
<PRE>
 sum :: Num a =&gt; [a] -&gt; a
 msum :: MonadPlus m =&gt; [m a] -&gt; m a</PRE>
<p>
This package is <i>implementation specific</i> insofar as the compiler may assume that certain items are defined here in a certain way. Changes may thus lead to compiler crashes or java code that will be rejected by the java compiler.</p>
<p>
In particular, desugared <b><SPAN CLASS="code">do</SPAN></b> expressions will reference <a class="tref" href="#Monad">Monad</a>, <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a> and <a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a>.</p>
<p>
This package is implicitly imported and besides the additional stuff covers most of what one would get by importing <i>Control.Monad</i> and <i>Control.Applicative</i> in Haskell.</p>
<h3>
Imports</h3>
<ul>
<li>
<div>
import <a HREF="../control/Category.html">Control.Category</a> as Category</div>
</li>
<li>
<div>
import <a HREF="./PreludeBase.html">Prelude.PreludeBase</a> as PreludeBase</div>
</li>
<li>
<div>
import <a HREF="./PreludeList.html">Prelude.PreludeList</a> as PreludeList</div>
</li>
<li>
<div>
import <a HREF="../control/Semigroupoid.html">Control.Semigroupoid</a> as Semigroupoid</div>
</li>
</ul>
<h3>
Table of Content</h3>
<ul class="data">
<li>
<div>
<a HREF="#data">Definitions</a></div>
<dl>
<dt>
<SPAN CLASS="code"><b>type </b><a class="tref" href="#Reader">Reader</a>  = <a class="tref" href="./PreludeBase.html#Function">-&gt;</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#Alt">Alt</a> <a class="tref" href="#Functor">Functor</a> f ⇒  f</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#Applicative">Applicative</a> (<a class="tref" href="#Functor">Functor</a> p, <a class="tref" href="#Apply">Apply</a> p) ⇒  p</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#Apply">Apply</a> <a class="tref" href="#Functor">Functor</a> f ⇒  f</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#Bind">Bind</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Apply">Apply</a> f) ⇒  f</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#Functor">Functor</a>  f</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#Monad">Monad</a> (<a class="tref" href="#Functor">Functor</a> m, <a class="tref" href="#Apply">Apply</a> m, <a class="tref" href="#Bind">Bind</a> m, <a class="tref" href="#Applicative">Applicative</a> m) ⇒  m</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#MonadAlt">MonadAlt</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Apply">Apply</a> f, <a class="tref" href="#Bind">Bind</a> f, <a class="tref" href="#Applicative">Applicative</a> f, <a class="tref" href="#Monad">Monad</a> f, <a class="tref" href="#Alt">Alt</a> f, <a class="tref" href="#Plus">Plus</a> f) ⇒  f</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#MonadFail">MonadFail</a> (<a class="tref" href="#Functor">Functor</a> m, <a class="tref" href="#Apply">Apply</a> m, <a class="tref" href="#Bind">Bind</a> m, <a class="tref" href="#Applicative">Applicative</a> m, <a class="tref" href="#Monad">Monad</a> m) ⇒  m</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#MonadOr">MonadOr</a> (<a class="tref" href="#Functor">Functor</a> mo, <a class="tref" href="#Apply">Apply</a> mo, <a class="tref" href="#Bind">Bind</a> mo, <a class="tref" href="#Applicative">Applicative</a> mo, <a class="tref" href="#Monad">Monad</a> mo, <a class="tref" href="#MonadZero">MonadZero</a> mo) ⇒  mo</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#MonadPlus">MonadPlus</a> (<a class="tref" href="#Functor">Functor</a> mp, <a class="tref" href="#Apply">Apply</a> mp, <a class="tref" href="#Bind">Bind</a> mp, <a class="tref" href="#Applicative">Applicative</a> mp, <a class="tref" href="#Monad">Monad</a> mp, <a class="tref" href="#MonadZero">MonadZero</a> mp) ⇒  mp</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#MonadZero">MonadZero</a> (<a class="tref" href="#Functor">Functor</a> mz, <a class="tref" href="#Apply">Apply</a> mz, <a class="tref" href="#Bind">Bind</a> mz, <a class="tref" href="#Applicative">Applicative</a> mz, <a class="tref" href="#Monad">Monad</a> mz) ⇒  mz</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>class </b><a class="tref" href="#Plus">Plus</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Alt">Alt</a> f) ⇒  f</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#_lt$_gt">&lt;$&gt;</a> ∷ <a class="tref" href="#Functor">Functor</a> f ⇒ (a → b) → f a → f b&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#apply">apply</a> ∷ <a class="tref" href="#Apply">Apply</a> p ⇒ p (a→b) → p a → p b</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftA">liftA</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b) → f a → f b</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftA2">liftA2</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c) → f a → f b → f c</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftA3">liftA3</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d) → f a → f b → f c → f d</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftA4">liftA4</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d → e) → f a → f b → f c → f d → f e</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftA5">liftA5</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d → e → g) → f a → f b → f c → f d → f e → f g</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#_eq_lt_lt">=&lt;&lt;</a> ∷ <a class="tref" href="#Bind">Bind</a> α ⇒ (γ→α β) → α γ → α β&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#_gt_eq_gt">&gt;=&gt;</a> ∷ <a class="tref" href="#Bind">Bind</a> δ ⇒ (α→δ β) → (β→δ γ) → α → δ γ&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#_lt_eq_lt">&lt;=&lt;</a> ∷ <a class="tref" href="#Bind">Bind</a> γ ⇒ (β→γ α) → (δ→γ β) → δ → γ α&nbsp;</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#forever">forever</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ α γ → α β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#_void">void</a> ∷ <a class="tref" href="#Functor">Functor</a> β ⇒ β α → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#msum">msum</a> ∷ <a class="tref" href="#MonadPlus">MonadPlus</a> α ⇒ <b>[α β]</b> → α β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#filterM">filterM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (α→β <a class="tref" href="./PreludeBase.html#Bool">Bool</a>) → <b>[α]</b> → β [α]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#shortFilterM">shortFilterM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (<b>α→β <a class="tref" href="./PreludeBase.html#Bool">Bool</a></b>) → <b>[α]</b> → β [α]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#replicateM">replicateM</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ <b><a class="tref" href="./PreludeBase.html#Int">Int</a></b> → m a → m [a]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#replicateM_">replicateM_</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ <b><a class="tref" href="./PreludeBase.html#Int">Int</a></b> → m a → m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#ap">ap</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ α (γ→β) → α γ → α β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftM">liftM</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ (a → b) → m a → m b</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftM2">liftM2</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (δ→γ→α) → β δ → β γ → β α</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftM3">liftM3</a> ∷ <a class="tref" href="#Monad">Monad</a> δ ⇒ (γ→α→β→ε) → δ γ → δ α → δ β → δ ε</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftM4">liftM4</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (ε→ζ→γ→δ→β) → α ε → α ζ → α γ → α δ → α β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#liftM5">liftM5</a> ∷ <a class="tref" href="#Monad">Monad</a> η ⇒ (ε→ζ→β→γ→α→δ) → η ε → η ζ → η β → η γ → η α → η δ</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#mapAndUnzipM">mapAndUnzipM</a> ∷ <a class="tref" href="#Monad">Monad</a> γ ⇒ (α→γ (δ, β)) → [α] → γ ([δ], [β])</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#zipWithM">zipWithM</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (γ→β→α δ) → <b>[γ]</b> → <b>[β]</b> → α [δ]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#zipWithM_">zipWithM_</a> ∷ <a class="tref" href="#Monad">Monad</a> γ ⇒ (α→β→γ δ) → <b>[α]</b> → <b>[β]</b> → γ <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#sequence">sequence</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ <b>[α β]</b> → α [β]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#shortSequence">shortSequence</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[β α]</b> → β [α]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#sequence_">sequence_</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[β α]</b> → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#mapM">mapM</a> ∷ <a class="tref" href="#Monad">Monad</a> γ ⇒ (β→γ α) → <b>[β]</b> → γ [α]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#mapM_">mapM_</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (α→β γ) → <b>[α]</b> → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#forM">forM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[γ]</b> → (γ→β α) → β [α]</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#forM_">forM_</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[α]</b> → (α→β γ) → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#_for">for</a> ∷ (<a class="tref" href="#Monad">Monad</a> m, <a class="tref" href="./PreludeList.html#ListSource">ListSource</a> listSource) ⇒ listSource e → (e → m a) → m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#foldM">foldM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (γ→α→β γ) → <b>γ</b> → <b>[α]</b> → β γ</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#shortFoldM">shortFoldM</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (β→γ→α β) → β → <b>[γ]</b> → α β</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#foldM_">foldM_</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (β→γ→α β) → β → [γ] → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#guard">guard</a> ∷ <a class="tref" href="#MonadZero">MonadZero</a> α ⇒ <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#when">when</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> → α <a class="tref" href="./PreludeBase.html#Unit">()</a> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#unless">unless</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> → α <a class="tref" href="./PreludeBase.html#Unit">()</a> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#runReader">runReader</a> ∷ (<b>r → a</b>) → r → a</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#mapReader">mapReader</a> ∷ (<b>a → b</b>) → (r → a) → r → b</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><a class="fref" href="#withReader">withReader</a> ∷ (e → r) → (<b>r → a</b>) → e → a</SPAN></dt>
<dd>
</dd>
</dl>
</li>
<li>
<div>
<a HREF="#instance">Instances</a></div>
<dl>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Applicative__minus_gt"> </a> <a class="tref" href="#Applicative">Applicative</a> <a class="tref" href="./PreludeBase.html#Function">-&gt;</a> a</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Functor_l_c_r"> </a> <a class="tref" href="#Functor">Functor</a> (a)</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Functor_l_cc_r"> </a> <a class="tref" href="#Functor">Functor</a> (a, b)</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Functor__lbrack_rbrack"> </a> <a class="tref" href="#Functor">Functor</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#MonadFail_Either"> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#Either">Either</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#MonadFail_ST"> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#ST">ST</a> s</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#MonadFail__lbrack_rbrack"> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#MonadPlus__lbrack_rbrack"> </a> <a class="tref" href="#MonadPlus">MonadPlus</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Monad__minus_gt"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#Function">-&gt;</a> a</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Monad_Either"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#Either">Either</a> left</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Monad_ST"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#ST">ST</a> s</SPAN></dt>
<dd>
</dd>
<dt>
<SPAN CLASS="code"><b>instance </b><a class="tref" href="#Monad__lbrack_rbrack"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd>
</dd>
</dl>
</li>
<li>
<div>
<a HREF="#case">Functions and Values by Type</a></div>
</li>
</ul>
<h2>
<a NAME="data">Definitions</a></h2>
<dl class="data">
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=Functor>Functor</a>  f</SPAN></dt>
<dd class="data">
<p>
The <a class="tref" href="#Functor">Functor</a> class is used for types that can be mapped over. Instances of <a class="tref" href="#Functor">Functor</a> should satisfy the following laws:</p>
<PRE>
 fmap id == id
 fmap (f . g) == fmap f . fmap g</PRE>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Applicative__minus_gt">-&gt;</a>, <a class="tref" href="#Functor_l_cc_r">(,,)</a>, <a class="tref" href="#Functor_l_c_r">(,)</a>, <a class="tref" href="#Functor__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Functor.fmap>fmap</a> ∷ <a class="tref" href="#Functor">Functor</a> f ⇒ (a → b) → f a → f b<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
Map a function over a <a class="tref" href="#Functor">Functor</a>   </p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=Apply>Apply</a> <a class="tref" href="#Functor">Functor</a> f ⇒  f</SPAN></dt>
<dd class="data">
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad__lbrack_rbrack">[]</a>, <a class="tref" href="#Applicative__minus_gt">-&gt;</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Apply._lt_star_gt>&lt;*&gt;</a> ∷ <a class="tref" href="#Apply">Apply</a> f ⇒ f (a→b) → f a → f b<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=_lt$_gt>&lt;$&gt;</a> ∷ <a class="tref" href="#Functor">Functor</a> f ⇒ (a → b) → f a → f b<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="data">
<p>
An infix synonym for <a class="fref" href="#Functor.fmap">Functor.fmap</a>. Left associative with precedence 4.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=Applicative>Applicative</a> (<a class="tref" href="#Functor">Functor</a> p, <a class="tref" href="#Apply">Apply</a> p) ⇒  p</SPAN></dt>
<dd class="data">
<p>
A functor with application, providing operations to</p>
<ul>
<LI>
 embed pure expressions (<a class="fref" href="#Applicative.pure">Applicative.pure</a>), and </LI>
<LI>
 sequence computations and combine their results (<a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a>). </LI>
</ul>
<p>
A minimal complete definition must include implementations of these functions satisfying the following laws:</p>
<dl>
<dt>
<i>identity</i></dt>
<dd>
<div>
 <SPAN CLASS="code">pure id &lt;*&gt; v = v</SPAN></div>
</dd>
<dt>
<i>composition</i></dt>
<dd>
<div>
 <SPAN CLASS="code">pure (•) &lt;<b>&gt; u &lt;</b>&gt; v &lt;<b>&gt; w = u &lt;</b>&gt; (v &lt;*&gt; w)</SPAN></div>
</dd>
<dt>
<i>homomorphism</i></dt>
<dd>
<div>
 <SPAN CLASS="code">pure f &lt;*&gt; pure x = pure (f x)</SPAN></div>
</dd>
<dt>
<i>interchange</i></dt>
<dd>
<div>
 <SPAN CLASS="code">u &lt;<b>&gt; pure y = pure ($ y) &lt;</b>&gt; u</SPAN></div>
</dd>
</dl>
<p>
The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</p>
<PRE>
  u *&gt; v = pure (const id)  &lt;*&gt; u &lt;*&gt; v
  u &lt;* v = pure const &lt;*&gt; u &lt;*&gt; v</PRE>
<p>
As a consequence of these laws, the <a class="tref" href="#Functor">Functor</a> instance for <SPAN CLASS="code">f</SPAN> will satisfy</p>
<PRE>
 fmap f x = pure f &lt;*&gt; x</PRE>
<p>
If <SPAN CLASS="code">f</SPAN> is also a <a class="tref" href="#Monad">Monad</a>, it should satisfy</p>
<PRE>
 (&lt;*&gt;) = ap</PRE>
<p>
(which implies that <a class="fref" href="#Applicative.pure">Applicative.pure</a> and <a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a> satisfy the applicative functor laws).</p>
<p>
Minimal complete definition: <a class="fref" href="#Applicative.pure">Applicative.pure</a> and <a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a>.</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad__lbrack_rbrack">[]</a>, <a class="tref" href="#Applicative__minus_gt">-&gt;</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Applicative._star_gt>*&gt;</a> ∷ <a class="tref" href="#Applicative">Applicative</a> p ⇒ p a → p b → p b<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
Sequence actions, discarding the value of the first argument.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Applicative._lt_star>&lt;*</a> ∷ <a class="tref" href="#Applicative">Applicative</a> p ⇒ p a → p b → p a<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
Sequence actions, discarding the value of the second argument.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Applicative.pure>pure</a> ∷ <a class="tref" href="#Applicative">Applicative</a> p ⇒ a → p a</SPAN></dt>
<dd class="func">
<p>
Lift a value   </p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=apply>apply</a> ∷ <a class="tref" href="#Apply">Apply</a> p ⇒ p (a→b) → p a → p b</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftA>liftA</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b) → f a → f b</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftA2>liftA2</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c) → f a → f b → f c</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftA3>liftA3</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d) → f a → f b → f c → f d</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftA4>liftA4</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d → e) → f a → f b → f c → f d → f e</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftA5>liftA5</a> ∷ <a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d → e → g) → f a → f b → f c → f d → f e → f g</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=Bind>Bind</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Apply">Apply</a> f) ⇒  f</SPAN></dt>
<dd class="data">
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Monad__minus_gt">-&gt;</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Bind._gt_gt_eq>&gt;&gt;=</a> ∷ <a class="tref" href="#Bind">Bind</a> f ⇒ f a → (a → f b) → f b<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
<p>
Sequentially compose two actions, passing any value produced by the first as an argument to the second.   </p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=Alt>Alt</a> <a class="tref" href="#Functor">Functor</a> f ⇒  f</SPAN></dt>
<dd class="data">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Alt._lt_bar_gt>&lt;|&gt;</a> ∷ <a class="tref" href="#Alt">Alt</a> f ⇒ f a → f a → f a<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=Plus>Plus</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Alt">Alt</a> f) ⇒  f</SPAN></dt>
<dd class="data">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Plus.pzero>pzero</a> ∷ <a class="tref" href="#Plus">Plus</a> f ⇒ f a</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=MonadAlt>MonadAlt</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Apply">Apply</a> f, <a class="tref" href="#Bind">Bind</a> f, <a class="tref" href="#Applicative">Applicative</a> f, <a class="tref" href="#Monad">Monad</a> f, <a class="tref" href="#Alt">Alt</a> f, <a class="tref" href="#Plus">Plus</a> f) ⇒  f</SPAN></dt>
<dd class="data">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadAlt._lt_plus_gt>&lt;+&gt;</a> ∷ <a class="tref" href="#MonadAlt">MonadAlt</a> f ⇒ f a → f a → f a<br><b>infixr</b>&nbsp;&nbsp;13</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=Monad>Monad</a> (<a class="tref" href="#Functor">Functor</a> m, <a class="tref" href="#Apply">Apply</a> m, <a class="tref" href="#Bind">Bind</a> m, <a class="tref" href="#Applicative">Applicative</a> m) ⇒  m</SPAN></dt>
<dd class="data">
<p>
The <a class="tref" href="#Monad">Monad</a> class defines the basic operations over a <i>monad</i>, a concept from a branch of mathematics known as <i>category theory</i>. From the perspective of a Frege programmer, however, it is best to think of a monad as an <i>abstract datatype</i> of actions.</p>
<p>
Frege’s <b><SPAN CLASS="code">do</SPAN></b> expressions provide a convenient syntax for writing monadic expressions.</p>
<p>
Instances of Monad should satisfy the following laws:</p>
<PRE>
 return a &gt;&gt;= k == k a
 m &gt;&gt;= return == m
 m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;= h</PRE>
<p>
Since instances of <a class="tref" href="#Monad">Monad</a> are also instances of <a class="tref" href="#Functor">Functor</a>, they additionally shall satisfy the law:</p>
<PRE>
 fmap f xs == xs &gt;&gt;= return • f</PRE>
<p>
which is also the default implementation of <a class="fref" href="#Functor.fmap">Functor.fmap</a>.</p>
<p>
The instances of <a class="tref" href="#Monad">Monad</a> for lists, <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> and <a class="tref" href="./PreludeBase.html#ST">ST</a> defined in the Prelude satisfy these laws.</p>
<p>
Minimal complete definition: <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a> and (<a class="fref" href="#Applicative.pure">Applicative.pure</a> or <a class="fref" href="#Monad._return">Monad.return</a>)</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Monad__minus_gt">-&gt;</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Monad._lt_star_gt>&lt;*&gt;</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ m (a→b) → m a → m b<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad._gt_gt>&gt;&gt;</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ m a → m b → m b<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
<p>
Sequentially compose two actions, discarding any value produced by the first, this works like sequencing operators (such as the semicolon) in imperative languages.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad.fmap>fmap</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ (a → b) → m a → m b<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad.join>join</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ m (m a) → m a</SPAN></dt>
<dd class="func">
<p>
The <a class="fref" href="#Monad.join">Monad.join</a> function is the conventional monad <b>join</b> operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad.pure>pure</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ <b>a</b> → m a</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad._return>return</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ <b>a</b> → m a</SPAN></dt>
<dd class="func">
<p>
Inject a value into the <a class="tref" href="#Monad">Monad</a>. This is the same as <a class="fref" href="#Applicative.pure">Applicative.pure</a>.</p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=MonadFail>MonadFail</a> (<a class="tref" href="#Functor">Functor</a> m, <a class="tref" href="#Apply">Apply</a> m, <a class="tref" href="#Bind">Bind</a> m, <a class="tref" href="#Applicative">Applicative</a> m, <a class="tref" href="#Monad">Monad</a> m) ⇒  m</SPAN></dt>
<dd class="data">
<p>
The <a class="tref" href="#MonadFail">MonadFail</a> class augments <a class="tref" href="#Monad">Monad</a> by adding the <a class="fref" href="#MonadFail.fail">MonadFail.fail</a> operation. This operation is not part of the mathematical definition of a monad.</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#MonadFail__lbrack_rbrack">[]</a>, <a class="tref" href="#MonadFail_Either">Either</a>, <a class="tref" href="#MonadFail_ST">ST</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadFail.fail>fail</a> ∷ <a class="tref" href="#MonadFail">MonadFail</a> m ⇒ <b><a class="tref" href="./PreludeBase.html#String">String</a></b> → m a</SPAN></dt>
<dd class="func">
<p>
Fail with a message.    </p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=MonadZero>MonadZero</a> (<a class="tref" href="#Functor">Functor</a> mz, <a class="tref" href="#Apply">Apply</a> mz, <a class="tref" href="#Bind">Bind</a> mz, <a class="tref" href="#Applicative">Applicative</a> mz, <a class="tref" href="#Monad">Monad</a> mz) ⇒  mz</SPAN></dt>
<dd class="data">
<p>
A <a class="tref" href="#Monad">Monad</a> with a left identity.</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#MonadPlus__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadZero.mzero>mzero</a> ∷ <a class="tref" href="#MonadZero">MonadZero</a> mz ⇒ mz a</SPAN></dt>
<dd class="func">
<p>
This value should satisfy <i>left zero</i>:</p>
<PRE>
 mzero &gt;&gt;= f = mzero   </PRE>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=MonadPlus>MonadPlus</a> (<a class="tref" href="#Functor">Functor</a> mp, <a class="tref" href="#Apply">Apply</a> mp, <a class="tref" href="#Bind">Bind</a> mp, <a class="tref" href="#Applicative">Applicative</a> mp, <a class="tref" href="#Monad">Monad</a> mp, <a class="tref" href="#MonadZero">MonadZero</a> mp) ⇒  mp</SPAN></dt>
<dd class="data">
<p>
A <a class="tref" href="#Monad">Monad</a> that also supports choice and failure and observes the following laws:</p>
<PRE>
 mzero `mplus`  v = v
 v `mplus` mzero  = v
 (a `mplus` b) `mplus` c = a `mplus` (b `mplus` c)
 (a `mplus` b) &gt;&gt;= f = (a &gt;&gt;= f) `mplus` (b &gt;&gt;= f)</PRE>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#MonadPlus__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadPlus.mplus>mplus</a> ∷ <a class="tref" href="#MonadPlus">MonadPlus</a> mp ⇒ mp a → mp a → mp a<br><b>infixr</b>&nbsp;&nbsp;13</SPAN></dt>
<dd class="func">
<p>
an associative operation   </p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>class </b><a name=MonadOr>MonadOr</a> (<a class="tref" href="#Functor">Functor</a> mo, <a class="tref" href="#Apply">Apply</a> mo, <a class="tref" href="#Bind">Bind</a> mo, <a class="tref" href="#Applicative">Applicative</a> mo, <a class="tref" href="#Monad">Monad</a> mo, <a class="tref" href="#MonadZero">MonadZero</a> mo) ⇒  mo</SPAN></dt>
<dd class="data">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadOr.orElse>orElse</a> ∷ <a class="tref" href="#MonadOr">MonadOr</a> mo ⇒ mo a → mo a → mo a</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=_eq_lt_lt>=&lt;&lt;</a> ∷ <a class="tref" href="#Bind">Bind</a> α ⇒ (γ→α β) → α γ → α β<br><b>infixr</b>&nbsp;&nbsp;2</SPAN></dt>
<dd class="data">
<p>
<a class="fref" href="#_eq_lt_lt">=&lt;&lt;</a> is the same as <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a> with the arguments flipped       </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=_gt_eq_gt>&gt;=&gt;</a> ∷ <a class="tref" href="#Bind">Bind</a> δ ⇒ (α→δ β) → (β→δ γ) → α → δ γ<br><b>infixr</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="data">
<p>
left to right Kleisli composition of monads   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=_lt_eq_lt>&lt;=&lt;</a> ∷ <a class="tref" href="#Bind">Bind</a> γ ⇒ (β→γ α) → (δ→γ β) → δ → γ α<br><b>infixr</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="data">
<p>
Right-to-left Kleisli composition of monads. (<a class="fref" href="#_gt_eq_gt">&gt;=&gt;</a>), with the arguments flipped   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=forever>forever</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ α γ → α β</SPAN></dt>
<dd class="data">
<p>
nowarn: deep recursion possible</p>
<p>
repeat action forever   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=_void>void</a> ∷ <a class="tref" href="#Functor">Functor</a> β ⇒ β α → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
discard or ignore result of evaluation, such as the return value of an <a class="tref" href="./PreludeBase.html#IO">IO</a> action.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=msum>msum</a> ∷ <a class="tref" href="#MonadPlus">MonadPlus</a> α ⇒ <b>[α β]</b> → α β</SPAN></dt>
<dd class="data">
<p>
<a class="fref" href="#msum">msum</a> generalizes the list-based <a class="fref" href="./PreludeList.html#concat">concat</a> function.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=filterM>filterM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (α→β <a class="tref" href="./PreludeBase.html#Bool">Bool</a>) → <b>[α]</b> → β [α]</SPAN></dt>
<dd class="data">
<p>
<a class="fref" href="#filterM">filterM</a> generalizes the list-based <a class="fref" href="./PreludeList.html#filter">filter</a> function.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=shortFilterM>shortFilterM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (<b>α→β <a class="tref" href="./PreludeBase.html#Bool">Bool</a></b>) → <b>[α]</b> → β [α]</SPAN></dt>
<dd class="data">
<p>
Version of <a class="fref" href="#filterM">filterM</a> that works on small lists with length &lt; 1000 only.</p>
<p>
Beware of stack overflow, and use <a class="fref" href="#filterM">filterM</a>, when in doubt.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=replicateM>replicateM</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ <b><a class="tref" href="./PreludeBase.html#Int">Int</a></b> → m a → m [a]</SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">replicateM n act</SPAN> performs the action <SPAN CLASS="code">n</SPAN> times, gathering the results.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=replicateM_>replicateM_</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ <b><a class="tref" href="./PreludeBase.html#Int">Int</a></b> → m a → m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
Like <a class="fref" href="#replicateM">replicateM</a>, but discards the result.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=ap>ap</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ α (γ→β) → α γ → α β</SPAN></dt>
<dd class="data">
<p>
In many situations, the <a class="fref" href="#liftM">liftM</a> operations can be replaced by uses of <a class="fref" href="#ap">ap</a>, which promotes function application.</p>
<PRE>
       return f `ap` x1 `ap` ... `ap` xn</PRE>
<p>
is equivalent to</p>
<PRE>
       liftMn f x1 x2 ... xn</PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftM>liftM</a> ∷ <a class="tref" href="#Monad">Monad</a> m ⇒ (a → b) → m a → m b</SPAN></dt>
<dd class="data">
<p>
Promote a function to a monad.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftM2>liftM2</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (δ→γ→α) → β δ → β γ → β α</SPAN></dt>
<dd class="data">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right.  For example,</p>
<PRE>
    liftM2 (+) [0,1] [0,2] = [0,2,1,3]</PRE>
<PRE>
    liftM2 (+) (Just 1) Nothing = Nothing   </PRE>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftM3>liftM3</a> ∷ <a class="tref" href="#Monad">Monad</a> δ ⇒ (γ→α→β→ε) → δ γ → δ α → δ β → δ ε</SPAN></dt>
<dd class="data">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right (cf. <a class="fref" href="#liftM2">liftM2</a>).   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftM4>liftM4</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (ε→ζ→γ→δ→β) → α ε → α ζ → α γ → α δ → α β</SPAN></dt>
<dd class="data">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right (cf. <a class="fref" href="#liftM2">liftM2</a>).   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=liftM5>liftM5</a> ∷ <a class="tref" href="#Monad">Monad</a> η ⇒ (ε→ζ→β→γ→α→δ) → η ε → η ζ → η β → η γ → η α → η δ</SPAN></dt>
<dd class="data">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right (cf. <a class="fref" href="#liftM2">liftM2</a>).   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=mapAndUnzipM>mapAndUnzipM</a> ∷ <a class="tref" href="#Monad">Monad</a> γ ⇒ (α→γ (δ, β)) → [α] → γ ([δ], [β])</SPAN></dt>
<dd class="data">
<p>
The <a class="fref" href="#mapAndUnzipM">mapAndUnzipM</a> function maps its first argument over a list, returning the result as a pair of lists. This function is mainly used with complicated data structures or a state-transforming monad.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=zipWithM>zipWithM</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (γ→β→α δ) → <b>[γ]</b> → <b>[β]</b> → α [δ]</SPAN></dt>
<dd class="data">
<p>
The <a class="fref" href="#zipWithM">zipWithM</a> function generalizes <a class="fref" href="./PreludeList.html#zipWith">zipWith</a> to arbitrary monads.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=zipWithM_>zipWithM_</a> ∷ <a class="tref" href="#Monad">Monad</a> γ ⇒ (α→β→γ δ) → <b>[α]</b> → <b>[β]</b> → γ <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
<a class="fref" href="#zipWithM_">zipWithM_</a> is the extension of <a class="fref" href="#zipWithM">zipWithM</a> which ignores the final result.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=sequence>sequence</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ <b>[α β]</b> → α [β]</SPAN></dt>
<dd class="data">
<p>
Turn a list of monadic values <SPAN CLASS="code">[m a]</SPAN> into a monadic value with a list <SPAN CLASS="code">m [a]</SPAN></p>
<PRE>
 sequence [Just 1, Just 3, Just 2] = Just [1,2,3]</PRE>
<p>
This version of <a class="fref" href="#sequence">sequence</a> runs in constant stack space, but needs heap space proportional to the size of the input list.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=shortSequence>shortSequence</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[β α]</b> → β [α]</SPAN></dt>
<dd class="data">
<p>
A version of <a class="fref" href="#sequence">sequence</a> that uses the stack and may overflow with longer lists.</p>
<p>
A length of about 500 should be ok in most cases.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=sequence_>sequence_</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[β α]</b> → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
fold (<a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a>) over a list of monadic values for side effects      </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=mapM>mapM</a> ∷ <a class="tref" href="#Monad">Monad</a> γ ⇒ (β→γ α) → <b>[β]</b> → γ [α]</SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">mapM f</SPAN> is equivalent to <SPAN CLASS="code">sequence • map f</SPAN>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=mapM_>mapM_</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (α→β γ) → <b>[α]</b> → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">mapM_ f</SPAN> is equivalent to <SPAN CLASS="code">sequence_ • map f</SPAN>   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=forM>forM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[γ]</b> → (γ→β α) → β [α]</SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">forM xs f</SPAN> = <SPAN CLASS="code">mapM_ f xs</SPAN>    </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=forM_>forM_</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ <b>[α]</b> → (α→β γ) → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=_for>for</a> ∷ (<a class="tref" href="#Monad">Monad</a> m, <a class="tref" href="./PreludeList.html#ListSource">ListSource</a> listSource) ⇒ listSource e → (e → m a) → m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">for listSource f</SPAN> is a Java-friendly alias for <SPAN CLASS="code">forM_</SPAN> that works on any list source   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=foldM>foldM</a> ∷ <a class="tref" href="#Monad">Monad</a> β ⇒ (γ→α→β γ) → <b>γ</b> → <b>[α]</b> → β γ</SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">foldM f a xs</SPAN> folds a monadic function <i>f</i> over the list <i>xs</i>.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=shortFoldM>shortFoldM</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (β→γ→α β) → β → <b>[γ]</b> → α β</SPAN></dt>
<dd class="data">
<p>
<a class="fref" href="#shortFoldM">shortFoldM</a> is suitable only for lists with a length way below 1000.</p>
<p>
Beware of stack overflow and use <a class="fref" href="#foldM">foldM</a> instead.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=foldM_>foldM_</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ (β→γ→α β) → β → [γ] → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">foldM_</SPAN> is the same as <a class="fref" href="#foldM">foldM</a>, but discards the result   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=guard>guard</a> ∷ <a class="tref" href="#MonadZero">MonadZero</a> α ⇒ <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">guard b</SPAN> is <SPAN CLASS="code">return ()</SPAN> if <SPAN CLASS="code">b</SPAN> is <b><SPAN CLASS="code">true</SPAN></b>, and <a class="fref" href="#MonadZero.mzero">MonadZero.mzero</a> otherwise.   </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=when>when</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> → α <a class="tref" href="./PreludeBase.html#Unit">()</a> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
<SPAN CLASS="code">when condition monadic</SPAN> returns /action/ of type <SPAN CLASS="code">Monad m =&gt; m ()</SPAN> if /condition/ is true, otherwise <a class="fref" href="#Monad._return">Monad.return</a> <a class="tref" href="./PreludeBase.html#Unit">()</a>.</p>
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=unless>unless</a> ∷ <a class="tref" href="#Monad">Monad</a> α ⇒ <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> → α <a class="tref" href="./PreludeBase.html#Unit">()</a> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="data">
<p>
opposite of <a class="fref" href="#when">when</a>      </p>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>type </b><a name=Reader>Reader</a>  = <a class="tref" href="./PreludeBase.html#Function">-&gt;</a></SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=runReader>runReader</a> ∷ (<b>r → a</b>) → r → a</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=mapReader>mapReader</a> ∷ (<b>a → b</b>) → (r → a) → r → b</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><a name=withReader>withReader</a> ∷ (e → r) → (<b>r → a</b>) → e → a</SPAN></dt>
<dd class="data">
</dd>
</dl>
<h2>
<a NAME="instance">Instances</a></h2>
<dl class="inst">
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Applicative__minus_gt> </a> <a class="tref" href="#Applicative">Applicative</a> <a class="tref" href="./PreludeBase.html#Function">-&gt;</a> a</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Applicative__minus_gt._star_gt>*&gt;</a> ∷ (β→α) → (β→γ) → β → γ<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Applicative__minus_gt._lt_star>&lt;*</a> ∷ (<b>γ→β</b>) → (γ→α) → γ → β<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Applicative__minus_gt._lt_star_gt>&lt;*&gt;</a> ∷ (<b>α→γ→β</b>) → (α→γ) → α → β<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Applicative__minus_gt.fmap>fmap</a> ∷ (α → γ) → (β→α) → β → γ<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Applicative__minus_gt.pure>pure</a> ∷ <b>α</b> → β → α</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Functor_l_c_r> </a> <a class="tref" href="#Functor">Functor</a> (a)</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Functor_l_c_r.fmap>fmap</a> ∷ (α → γ) → <b>(β, α)</b> → (β, γ)<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Functor_l_cc_r> </a> <a class="tref" href="#Functor">Functor</a> (a, b)</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Functor_l_cc_r.fmap>fmap</a> ∷ (α → γ) → <b>(δ, β, α)</b> → (δ, β, γ)<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Functor__lbrack_rbrack> </a> <a class="tref" href="#Functor">Functor</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Functor__lbrack_rbrack.fmap>fmap</a> ∷ (β → α) → <b>[β]</b> → [α]<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=MonadFail_Either> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#Either">Either</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadFail_Either.fail>fail</a> ∷ <a class="tref" href="./PreludeBase.html#String">String</a> → (<a class="tref" href="./PreludeBase.html#String">String</a> | α)</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=MonadFail_ST> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#ST">ST</a> s</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadFail_ST.fail>fail</a> ∷ <b><a class="tref" href="./PreludeBase.html#String">String</a></b> → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=MonadFail__lbrack_rbrack> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadFail__lbrack_rbrack.fail>fail</a> ∷ <a class="tref" href="./PreludeBase.html#String">String</a> → [α]</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=MonadPlus__lbrack_rbrack> </a> <a class="tref" href="#MonadPlus">MonadPlus</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=MonadPlus__lbrack_rbrack.mplus>mplus</a> ∷ <b>[α]</b> → [α] → [α]<br><b>infixr</b>&nbsp;&nbsp;13</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=MonadPlus__lbrack_rbrack.mzero>mzero</a> ∷ [α]</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Monad__minus_gt> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#Function">-&gt;</a> a</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Monad__minus_gt._gt_gt>&gt;&gt;</a> ∷ (α→γ) → (<b>α→β</b>) → α → β<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__minus_gt._gt_gt_eq>&gt;&gt;=</a> ∷ (β→α) → (<b>α → β→γ</b>) → β → γ<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__minus_gt.join>join</a> ∷ (<b>α→α→β</b>) → α → β</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__minus_gt._return>return</a> ∷ <b>α</b> → β → α</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Monad_Either> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#Either">Either</a> left</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either._star_gt>*&gt;</a> ∷ (γ | β) → (γ | α) → (γ | α)<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either._lt_star>&lt;*</a> ∷ (α | γ) → (α | β) → (α | γ)<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either._lt_star_gt>&lt;*&gt;</a> ∷ (α | γ→β) → (α | γ) → (α | β)<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either._gt_gt>&gt;&gt;</a> ∷ <b>(β | α)</b> → (β | γ) → (β | γ)<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either._gt_gt_eq>&gt;&gt;=</a> ∷ <b>(β | α)</b> → (α → (β | γ)) → (β | γ)<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either.fmap>fmap</a> ∷ (β → α) → <b>(γ | β)</b> → (γ | α)<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either.join>join</a> ∷ <b>(β | (β | α))</b> → (β | α)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either.pure>pure</a> ∷ <b>α</b> → (β | α)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_Either._return>return</a> ∷ α → (β | α)</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Monad_ST> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#ST">ST</a> s</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Monad_ST._star_gt>*&gt;</a> ∷ <a class="tref" href="./PreludeBase.html#ST">ST</a> α γ → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_ST._lt_star>&lt;*</a> ∷ <a class="tref" href="./PreludeBase.html#ST">ST</a> β α → <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_ST._lt_star_gt>&lt;*&gt;</a> ∷ <a class="tref" href="./PreludeBase.html#ST">ST</a> γ (β→α) → <a class="tref" href="./PreludeBase.html#ST">ST</a> γ β → <a class="tref" href="./PreludeBase.html#ST">ST</a> γ α<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_ST._gt_gt>&gt;&gt;</a> ∷ <b><a class="tref" href="./PreludeBase.html#ST">ST</a> α γ</b> → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=ST._gt_gt_eq>&gt;&gt;=</a> ∷ <b><a class="tref" href="./PreludeBase.html#ST">ST</a> β γ</b> → (γ→<a class="tref" href="./PreludeBase.html#ST">ST</a> β α) → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_ST.fmap>fmap</a> ∷ (γ → β) → <b><a class="tref" href="./PreludeBase.html#ST">ST</a> α γ</b> → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_ST.join>join</a> ∷ <b><a class="tref" href="./PreludeBase.html#ST">ST</a> β (<a class="tref" href="./PreludeBase.html#ST">ST</a> β α)</b> → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad_ST.pure>pure</a> ∷ <b>α</b> → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=ST._return>return</a> ∷ α → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name=Monad__lbrack_rbrack> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack._star_gt>*&gt;</a> ∷ [β] → [α] → [α]<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack._lt_star>&lt;*</a> ∷ [α] → [β] → [α]<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack._lt_star_gt>&lt;*&gt;</a> ∷ [α→β] → [α] → [β]<br><b>infixl</b>&nbsp;&nbsp;4</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack._gt_gt>&gt;&gt;</a> ∷ <b>[α]</b> → [β] → [β]<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack._gt_gt_eq>&gt;&gt;=</a> ∷ <b>[α]</b> → (α → [β]) → [β]<br><b>infixl</b>&nbsp;&nbsp;3</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack.join>join</a> ∷ <b>[[α]]</b> → [α]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack.pure>pure</a> ∷ <b>α</b> → [α]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name=Monad__lbrack_rbrack._return>return</a> ∷ α → [α]</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
</dl>
<h2>
<a NAME="case">Functions and Values by Type</a></h2>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> → (<a class="tref" href="./PreludeBase.html#String">String</a> | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadFail_Either.fail">MonadFail_Either.fail</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> → [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadFail__lbrack_rbrack.fail">MonadFail_[].fail</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[[α]] → [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack.join">Monad_[].join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] → [α] → [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadPlus__lbrack_rbrack.mplus">MonadPlus_[].mplus</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α → [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._return">Monad_[].return</a>, <a class="fref" href="#Monad__lbrack_rbrack.pure">Monad_[].pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ <a class="tref" href="./PreludeBase.html#Bool">Bool</a> → α <a class="tref" href="./PreludeBase.html#Unit">()</a> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#unless">unless</a>, <a class="fref" href="#when">when</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadZero">MonadZero</a> α ⇒ <a class="tref" href="./PreludeBase.html#Bool">Bool</a> → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#guard">guard</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadPlus__lbrack_rbrack.mzero">MonadPlus_[].mzero</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(r → a) → r → a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#runReader">runReader</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β → α) → [β] → [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Functor__lbrack_rbrack.fmap">Functor_[].fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α→α→β) → α → β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__minus_gt.join">Monad_-&gt;.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β | (β | α)) → (β | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either.join">Monad_Either.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> β (<a class="tref" href="./PreludeBase.html#ST">ST</a> β α) → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST.join">Monad_ST.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadFail_ST.fail">MonadFail_ST.fail</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α→β] → [α] → [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._lt_star_gt">Monad_[].&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] → (α → [β]) → [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._gt_gt_eq">Monad_[].&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] → [β] → [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._lt_star">Monad_[].&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] → [β] → [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._gt_gt">Monad_[].&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[β] → [α] → [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._star_gt">Monad_[].*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α → β → α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt.pure">Applicative_-&gt;.pure</a>, <a class="fref" href="#Monad__minus_gt._return">Monad_-&gt;.return</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α → (β | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._return">Monad_Either.return</a>, <a class="fref" href="#Monad_Either.pure">Monad_Either.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST.pure">Monad_ST.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Alt">Alt</a> f ⇒ f a → f a → f a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Alt._lt_bar_gt">Alt.&lt;|&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> p ⇒ a → p a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative.pure">Applicative.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Functor">Functor</a> β ⇒ β α → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_void">void</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m ⇒ m (m a) → m a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m ⇒ <a class="tref" href="./PreludeBase.html#Int">Int</a> → m a → m [a]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#replicateM">replicateM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m ⇒ <a class="tref" href="./PreludeBase.html#Int">Int</a> → m a → m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#replicateM_">replicateM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m ⇒ a → m a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad._return">Monad.return</a>, <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ [α β] → α [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#sequence">sequence</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ (α→β <a class="tref" href="./PreludeBase.html#Bool">Bool</a>) → [α] → β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#filterM">filterM</a>, <a class="fref" href="#shortFilterM">shortFilterM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ [β α] → β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#shortSequence">shortSequence</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ [β α] → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#sequence_">sequence_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadAlt">MonadAlt</a> f ⇒ f a → f a → f a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt._lt_plus_gt">MonadAlt.&lt;+&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadFail">MonadFail</a> m ⇒ <a class="tref" href="./PreludeBase.html#String">String</a> → m a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadFail.fail">MonadFail.fail</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadOr">MonadOr</a> mo ⇒ mo a → mo a → mo a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadOr.orElse">MonadOr.orElse</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadPlus">MonadPlus</a> mp ⇒ mp a → mp a → mp a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadPlus.mplus">MonadPlus.mplus</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadPlus">MonadPlus</a> α ⇒ [α β] → α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#msum">msum</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadZero">MonadZero</a> mz ⇒ mz a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadZero.mzero">MonadZero.mzero</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Plus">Plus</a> f ⇒ f a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Plus.pzero">Plus.pzero</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(a → b) → (r → a) → r → b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapReader">mapReader</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(e → r) → (r → a) → e → a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#withReader">withReader</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α → γ) → (β, α) → (β, γ)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Functor_l_c_r.fmap">Functor_(,).fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α → γ) → (β→α) → β → γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt.fmap">Applicative_-&gt;.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β → α) → (γ | β) → (γ | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either.fmap">Monad_Either.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(γ → β) → <a class="tref" href="./PreludeBase.html#ST">ST</a> α γ → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST.fmap">Monad_ST.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α→γ→β) → (α→γ) → α → β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt._lt_star_gt">Applicative_-&gt;.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α→γ) → (α→β) → α → β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__minus_gt._gt_gt">Monad_-&gt;.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β→α) → (α → β→γ) → β → γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__minus_gt._gt_gt_eq">Monad_-&gt;.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β→α) → (β→γ) → β → γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt._star_gt">Applicative_-&gt;.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(γ→β) → (γ→α) → γ → β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt._lt_star">Applicative_-&gt;.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α | γ→β) → (α | γ) → (α | β)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._lt_star_gt">Monad_Either.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α | γ) → (α | β) → (α | γ)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._lt_star">Monad_Either.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β | α) → (α → (β | γ)) → (β | γ)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._gt_gt_eq">Monad_Either.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β | α) → (β | γ) → (β | γ)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._gt_gt">Monad_Either.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(γ | β) → (γ | α) → (γ | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._star_gt">Monad_Either.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> α γ → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β → <a class="tref" href="./PreludeBase.html#ST">ST</a> α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST._star_gt">Monad_ST.*&gt;</a>, <a class="fref" href="#Monad_ST._gt_gt">Monad_ST.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> β α → <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ → <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST._lt_star">Monad_ST.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> γ (β→α) → <a class="tref" href="./PreludeBase.html#ST">ST</a> γ β → <a class="tref" href="./PreludeBase.html#ST">ST</a> γ α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST._lt_star_gt">Monad_ST.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b) → f a → f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA">liftA</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> p ⇒ p a → p b → p a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> p ⇒ p a → p b → p b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Apply">Apply</a> f ⇒ f (a→b) → f a → f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Apply">Apply</a> p ⇒ p (a→b) → p a → p b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#apply">apply</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> f ⇒ f a → (a → f b) → f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> α ⇒ (γ→α β) → α γ → α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_eq_lt_lt">=&lt;&lt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Functor">Functor</a> f ⇒ (a → b) → f a → f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_lt$_gt">&lt;$&gt;</a>, <a class="fref" href="#Functor.fmap">Functor.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m ⇒ (a → b) → m a → m b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM">liftM</a>, <a class="fref" href="#Monad.fmap">Monad.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m ⇒ m (a→b) → m a → m b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m ⇒ m a → m b → m b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ (β→γ→α β) → β → [γ] → α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#foldM_">foldM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ (β→γ→α β) → β → [γ] → α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#shortFoldM">shortFoldM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ α (γ→β) → α γ → α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#ap">ap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ α γ → α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#forever">forever</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ (α→β γ) → [α] → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapM_">mapM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ (γ→α→β γ) → γ → [α] → β γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#foldM">foldM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ [α] → (α→β γ) → β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#forM_">forM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ [γ] → (γ→β α) → β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#forM">forM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> γ ⇒ (β→γ α) → [β] → γ [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapM">mapM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α → γ) → (δ, β, α) → (δ, β, γ)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Functor_l_cc_r.fmap">Functor_(,,).fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c) → f a → f b → f c</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA2">liftA2</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> γ ⇒ (β→γ α) → (δ→γ β) → δ → γ α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_lt_eq_lt">&lt;=&lt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> δ ⇒ (α→δ β) → (β→δ γ) → α → δ γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_gt_eq_gt">&gt;=&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(<a class="tref" href="#Monad">Monad</a> m, <a class="tref" href="./PreludeList.html#ListSource">ListSource</a> listSource) ⇒ listSource e → (e → m a) → m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_for">for</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ (γ→β→α δ) → [γ] → [β] → α [δ]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#zipWithM">zipWithM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β ⇒ (δ→γ→α) → β δ → β γ → β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM2">liftM2</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> γ ⇒ (α→β→γ δ) → [α] → [β] → γ <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#zipWithM_">zipWithM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> γ ⇒ (α→γ (δ, β)) → [α] → γ ([δ], [β])</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapAndUnzipM">mapAndUnzipM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d) → f a → f b → f c → f d</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA3">liftA3</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> δ ⇒ (γ→α→β→ε) → δ γ → δ α → δ β → δ ε</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM3">liftM3</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d → e) → f a → f b → f c → f d → f e</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA4">liftA4</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α ⇒ (ε→ζ→γ→δ→β) → α ε → α ζ → α γ → α δ → α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM4">liftM4</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f ⇒ (a → b → c → d → e → g) → f a → f b → f c → f d → f e → f g</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA5">liftA5</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> η ⇒ (ε→ζ→β→γ→α→δ) → η ε → η ζ → η β → η γ → η α → η δ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM5">liftM5</a></p>
</dd>
</dl>
<p>
<a HREF="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></a></p>
</BODY>
</HTML>
